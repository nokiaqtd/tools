<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NRREL Mapping</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#f6f8fb;--card:#ffffff;--muted:#6b7280;--accent:#0f62ff}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;background:var(--bg);color:#0b1220}
    .wrap{max-width:980px;margin:36px auto;padding:20px}
    .card{background:var(--card);border-radius:12px;box-shadow:0 6px 18px rgba(11,17,32,0.06);padding:20px}
    h2{margin:0 0 6px;font-size:18px}
    .lead{margin:0 0 14px;color:var(--muted);font-size:13px}
    .row{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
    input[type=file]{display:block}
    .controls{display:flex;gap:8px;margin-top:12px}
    button{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    button.ghost{background:#eef2ff;color:var(--accent);border:1px solid rgba(15,98,255,0.08)}
    .small{font-size:12px;color:var(--muted)}
    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px}
    .file-item{margin-top:6px}
    label.small{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    .file-block{background:#fbfdff;border-radius:8px;padding:10px;border:1px solid #eef6ff}
    #logArea{white-space:pre-wrap; background:#0b1220;color:#e6eefb;padding:10px;border-radius:8px;margin-top:12px;max-height:320px;overflow:auto;font-family:monospace;font-size:12px;display:none}
    #warningsBlock{margin-top:10px;white-space:pre-wrap;background:#fff7f0;border-radius:6px;padding:8px;border:1px solid #ffd8b5;color:#7a3b00;max-height:320px;overflow:auto;font-family:monospace}
    /* hide download until ready */
    #downloadBtn { display: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2>NRREL Mapping</h2>
      <p class="lead">Upload: <strong>nrrel_alarms.csv</strong>, <strong>nrcel.csv</strong>, <strong>xymrbts.csv</strong> (all required)</p>

      <div class="row">
        <div style="flex:1;min-width:320px">
          <div class="file-block">
            <div class="file-item">
              <label class="small">1) nrrel_alarms.csv</label>
              <input id="fileAlarms" type="file" accept=".csv" />
            </div>
            <div class="file-item">
              <label class="small">2) nrcel.csv //auto find NRCELL's $dn and physCellId</label>
              <input id="fileNrcel" type="file" accept=".csv" />
            </div>
            <div class="file-item">
              <label class="small">3) xymrbts.csv</label>
              <input id="fileXymrbts" type="file" accept=".csv" />
            </div>
          </div>

          <div id="notes" class="small" style="margin-top:10px">
            Notes: csv filename is flexible but all input mandatory
          </div>

          <div id="warningsArea"></div>
        </div>

        <div style="width:260px">
          <label class="small">Output filename</label>
          <input id="outname" value="nrrel-mapping.csv" style="width:100%;padding:8px;border-radius:8px;border:1px solid #e6eefb;margin-top:6px" />
          <div class="controls" style="margin-top:12px">
            <button id="processBtn" disabled>Process</button>
            <button id="downloadBtn" class="ghost" disabled>Download CSV</button>
          </div>
        </div>
      </div>

      <div id="status" class="small" style="margin-top:8px;color:var(--muted)"></div>
      <div id="logArea"></div>

      <div class="footer">
        <div class="small"></div>
      </div>
    </div>
  </div>

<script>
/* Memory-safe fast version, but ALWAYS produce a chunked Blob so the Download button is available.
   - createWriter now always uses chunked-mode
*/

const YIELD_EVERY = 10000;

const fileAlarms = document.getElementById('fileAlarms');
const fileNrcel = document.getElementById('fileNrcel');
const fileXymrbts = document.getElementById('fileXymrbts');
const processBtn = document.getElementById('processBtn');
const downloadBtn = document.getElementById('downloadBtn');
const outnameInput = document.getElementById('outname');
const statusEl = document.getElementById('status');
const logArea = document.getElementById('logArea');
const notesEl = document.getElementById('notes');
const warningsArea = document.getElementById('warningsArea');

let tailLogs = [];
let warnings = [];
let fallbackBlobUrl = null;

function allSelected(){ return fileAlarms.files.length && fileNrcel.files.length && fileXymrbts.files.length; }
[fileAlarms,fileNrcel,fileXymrbts].forEach(el => el.addEventListener('change', ()=>{ processBtn.disabled = !allSelected(); }));

function appendTail(line){
  tailLogs.push(line);
  if (tailLogs.length > 200) tailLogs.shift();
  logArea.style.display = tailLogs.length ? '' : 'none';
  logArea.textContent = tailLogs.join('\n');
  logArea.scrollTop = logArea.scrollHeight;
}
function logInfo(msg){ const s=(new Date()).toISOString() + ' INFO: ' + msg; appendTail(s); statusEl.textContent = msg; }
function logWarn(msg){ const s=(new Date()).toISOString() + ' WARN: ' + msg; warnings.push(s); appendTail(s); }
function logCompare(msg){ /* suppressed for speed */ }
function logNearest(msg){ /* minimal */ appendTail((new Date()).toISOString() + ' NEAREST: ' + msg.split(' ')[0]); }

// streaming helper
async function streamFileLines(file, onLine){
  const reader = file.stream().getReader();
  const decoder = new TextDecoder('utf-8');
  let { value, done } = await reader.read();
  let buf = '';
  let lineNo = 0;
  while (!done) {
    buf += decoder.decode(value, { stream: true });
    let parts = buf.split(/\r\n|\n/);
    buf = parts.pop();
    for (const p of parts){
      lineNo++;
      await onLine(p, lineNo);
    }
    ({ value, done } = await reader.read());
  }
  if (buf.length) { lineNo++; await onLine(buf, lineNo); }
  reader.releaseLock();
}

// csv parse (fast)
function parseCSVLine(line){
  if (!line.includes('"')) return line.split(',');
  const out=[]; let cur='', inQ=false;
  for (let i=0;i<line.length;i++){
    const ch=line[i];
    if (ch==='"'){ if (inQ && line[i+1]==='"'){ cur+='"'; i++; } else inQ=!inQ; }
    else if (ch===',' && !inQ){ out.push(cur); cur=''; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function escapeCsv(val){ if (val===null||val===undefined) return ''; const s=String(val); if (s.includes(',')||s.includes('"')||s.includes('\n')) return '"' + s.replace(/"/g,'""') + '"'; return s; }

function extractMrbtsFromDn(dn){
  if (!dn) return null;
  const marker='PLMN-PLMN/MRBTS-';
  const idx = dn.indexOf(marker);
  if (idx !== -1){
    const rest = dn.slice(idx+marker.length);
    const slash = rest.indexOf('/');
    const m = slash===-1?rest:rest.slice(0,slash);
    if (/^\d+$/.test(m)) return m;
  }
  const mm = dn.match(/(\d{3,})/);
  return mm?mm[1]:null;
}
function extractGnbAndLcridFromDn(dn){
  const mG = dn.match(/NRBTS-(\d+)/i);
  const mL = dn.match(/NRCELL-(\d+)/i);
  return { gnb:(mG && mG[1])||'', lcrid:(mL&&mL[1])||'' };
}
function haversineMeters(lat1, lon1, lat2, lon2){
  const toRad = d => d*Math.PI/180;
  const R=6371000;
  const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const dφ = toRad(lat2-lat1), dλ = toRad(lon2-lon1);
  const a = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
  return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// load xymrbts
async function loadXymrbts(file){
  logInfo('Loading xymrbts...');
  const map = new Map();
  let lines=0;
  await streamFileLines(file, async (line, ln) => {
    lines++;
    if (!line.trim()) return;
    const cols = parseCSVLine(line);
    if (cols.length < 3) { logWarn(`xymrbts line ${ln} <3 cols`); return; }
    const lon = Number((cols[0]||'').trim()), lat = Number((cols[1]||'').trim()), mrb = (cols[2]||'').trim();
    if (ln===1 && (Number.isNaN(lon)||Number.isNaN(lat))) return;
    if (Number.isNaN(lon) || Number.isNaN(lat) || !mrb) { logWarn(`invalid xymrbts at ${ln}`); return; }
    map.set(String(mrb), {lon,lat});
    if (lines % 50000 === 0) logInfo(`xymrbts processed ${lines}`);
    if (lines % YIELD_EVERY === 0) await new Promise(r=>setTimeout(r,0));
  });
  logInfo(`Finished xymrbts: ${map.size} entries`);
  return map;
}

// load nrcel precompute - DYNAMIC column detection for dn and physCellid
async function loadNrcelPrecomputed(file, xymrbtsmap){
  logInfo('Loading nrcel and precomputing (dynamic column detection)...');

  // fallback indexes (keep old defaults in case detection fails)
  const FALLBACK_COL_DN = 37;  // previous INDEX_AL
  const FALLBACK_COL_PCI = 43; // previous INDEX_AR

  let colx = -1;
  let col_dn = -1;
  let col_pci = -1;

  const map = new Map();
  let lnCount=0, stored=0;
  await streamFileLines(file, async (line, ln) => {
    lnCount++;
    if (!line.trim()) return;

    const cols = parseCSVLine(line);

    // Row 1: find 'com.nokia.srbts.nrbts:NRCELL' to get colx
    if (ln === 1) {
      for (let i=0;i<cols.length;i++){
        if ((cols[i]||'').trim() === 'com.nokia.srbts.nrbts:NRCELL') { colx = i; break; }
      }
      if (colx === -1) {
        logWarn("nrcel row1: 'com.nokia.srbts.nrbts:NRCELL' not found in row 1 — will attempt fallback columns.");
      } else {
        logInfo(`nrcel: found colx at index ${colx} (0-based)`);
      }
      return; // header row, do not process as data
    }

    // Row 2: find '$dn' starting from colx, then 'physCellId' starting from col_dn
    if (ln === 2) {
      if (colx !== -1) {
        // start from colx
        for (let j = colx; j < cols.length; j++){
          if ((cols[j]||'').trim() === '$dn') { col_dn = j; break; }
        }
        if (col_dn === -1) {
          logWarn("nrcel row2: '$dn' not found starting from colx — will attempt fallback.");
        } else {
          logInfo(`nrcel: found col_dn at index ${col_dn} (0-based)`);
          // find physCellId starting from col_dn
          for (let k = col_dn; k < cols.length; k++){
            if ((cols[k]||'').trim() === 'physCellId') { col_pci = k; break; }
          }
          if (col_pci === -1) {
            logWarn("nrcel row2: 'physCellId' not found starting from col_dn — will attempt fallback.");
          } else {
            logInfo(`nrcel: found col_pci at index ${col_pci} (0-based)`);
          }
        }
      } else {
        // colx not found, attempt to directly find $dn and physCellId in row2 (best-effort)
        for (let j = 0; j < cols.length; j++){
          if ((cols[j]||'').trim() === '$dn') { col_dn = j; break; }
        }
        if (col_dn !== -1) {
          logInfo(`nrcel: fallback found col_dn at index ${col_dn} (0-based)`);
          for (let k = col_dn; k < cols.length; k++){
            if ((cols[k]||'').trim() === 'physCellId') { col_pci = k; break; }
          }
          if (col_pci !== -1) logInfo(`nrcel: fallback found col_pci at index ${col_pci} (0-based)`);
        } else {
          logWarn("nrcel row2: fallback '$dn' not found in row 2.");
        }
      }

      // If detection failed, use fallbacks but log it
      if (col_dn === -1) {
        col_dn = FALLBACK_COL_DN;
        logInfo(`nrcel: using fallback col_dn=${col_dn}`);
      }
      if (col_pci === -1) {
        col_pci = FALLBACK_COL_PCI;
        logInfo(`nrcel: using fallback col_pci=${col_pci}`);
      }

      return; // header row, do not process as data
    }

    // From here on, ln >= 3 -> data rows
    // ensure we have enough columns
    const maxNeededIndex = Math.max(col_dn, col_pci);
    if (cols.length <= maxNeededIndex) { logWarn(`nrcel line ${ln} cols=${cols.length} missing expected columns up to ${maxNeededIndex}`); return; }

    const dn = (cols[col_dn]||'').trim();
    const phys = (cols[col_pci]||'').trim();
    if (!phys) return;
    if (!dn) { logWarn(`nrcel missing dn at line ${ln} phys=${phys}`); return; }

    const mrb = extractMrbtsFromDn(dn);
    if (!mrb) return;
    const coord = xymrbtsmap.get(String(mrb));
    if (!coord) return;
    const { gnb, lcrid } = extractGnbAndLcridFromDn(dn);
    const entry = { dn, lat: coord.lat, lon: coord.lon, gnb, lcrid };
    const key = String(phys);
    let arr = map.get(key);
    if (!arr){ arr = []; map.set(key, arr); }
    arr.push(entry);
    stored++;
    if (stored % 50000 === 0) logInfo(`nrcel candidates stored ${stored}`);
    if (stored % YIELD_EVERY === 0) await new Promise(r => setTimeout(r,0));
  });
  logInfo(`Finished nrcel precompute. physCount=${map.size}`);
  return map;
}

// CHUNKED writer (always used now)
async function createChunkedWriter(){
  const parts = [];
  let rows = 0;
  return {
    async write(text){ parts.push(text); rows++; if (rows % 5000 === 0) await new Promise(r=>setTimeout(r,0)); },
    async close(){ const blob = new Blob(parts,{type:'text/csv;charset=utf-8;'}); fallbackBlobUrl = URL.createObjectURL(blob); },
    async getBlob(){ return fallbackBlobUrl; }
  };
}

// main processing
async function processAll(){
  tailLogs = []; warnings = []; fallbackBlobUrl = null; logArea.style.display='none'; warningsArea.innerHTML=''; notesEl.textContent='Processing...';
  processBtn.disabled = true; downloadBtn.style.display='none'; downloadBtn.disabled = true; statusEl.textContent='Starting...';

  const fA = fileAlarms.files[0], fN = fileNrcel.files[0], fX = fileXymrbts.files[0];
  if (!fA || !fN || !fX){ logWarn('All three files required'); processBtn.disabled=false; return; }

  const writer = await createChunkedWriter();
  await writer.write('source_dn,physCellId,target_dn,gNB,Lcrid,distance_m\r\n');

  const xymap = await loadXymrbts(fX);
  const pciMap = await loadNrcelPrecomputed(fN, xymap);

  logInfo('Processing nrrel_alarms...');
  let lnCount=0, processed=0, outRows=0;
  await streamFileLines(fA, async (line, ln) => {
    lnCount++;
    if (!line) return;
    if (ln === 1) return;
    const cols = parseCSVLine(line);
    if (cols.length <= Math.max(8,22)) { logWarn(`nrrel_alarms line ${ln} cols=${cols.length}`); return; }
    const source_dn = (cols[8]||'').trim();
    const info = (cols[22]||'').trim();
    if (!source_dn){ logWarn(`missing source_dn at line ${ln}`); return; }

    const pciMatches=[];
    const regex = /NR-PCI\s*=\s*(\d+)\s*COUNT/gi;
    let m;
    while ((m = regex.exec(info)) !== null) pciMatches.push(m[1]);
    if (pciMatches.length === 0){ processed++; return; }

    const source_mrb = extractMrbtsFromDn(source_dn);
    if (!source_mrb){ logWarn(`cannot extract mrbts from source_dn='${source_dn}' line ${ln}`); processed++; return; }
    const srcCoord = xymap.get(String(source_mrb));
    if (!srcCoord){ logWarn(`source mrbts=${source_mrb} not found for source_dn='${source_dn}'`); processed++; return; }

    for (const pci of pciMatches){
      const physKey = String(pci);
      const candidates = pciMap.get(physKey);
      if (!candidates || candidates.length === 0) {
        logWarn(`no target candidate for phys=${physKey} source='${source_dn}'`);
        await writer.write(`${escapeCsv(source_dn)},${escapeCsv(physKey)},,,,\r\n`);
        outRows++;
        continue;
      }
      let nearest = null;
      for (let i=0;i<candidates.length;i++){
        const t = candidates[i];
        const d = haversineMeters(srcCoord.lat, srcCoord.lon, t.lat, t.lon);
        if (!nearest || d < nearest.distance_m) nearest = { target_dn: t.dn, distance_m: d, gnb: t.gnb, lcrid: t.lcrid };
      }
      if (!nearest) {
        logWarn(`no valid coords for phys=${physKey} source='${source_dn}'`);
        await writer.write(`${escapeCsv(source_dn)},${escapeCsv(physKey)},,,,\r\n`);
        outRows++;
      } else {
        await writer.write(`${escapeCsv(source_dn)},${escapeCsv(physKey)},${escapeCsv(nearest.target_dn)},${escapeCsv(nearest.gnb)},${escapeCsv(nearest.lcrid)},${nearest.distance_m.toFixed(3)}\r\n`);
        outRows++;
      }
    }

    processed++;
    if (processed % 10000 === 0) logInfo(`Processed ${processed} nrrel rows...`);
    if (processed % YIELD_EVERY === 0) await new Promise(r=>setTimeout(r,0));
  });

  await writer.close();

  logInfo(`Finished. processedRows=${processed} outputRows=${outRows}`);
  notesEl.textContent = `Warnings: ${warnings.length} — Alarm rows processed: ${processed} — Output rows: ${outRows}`;
  if (warnings.length) {
    const wg = document.createElement('div'); wg.id='warningsBlock'; wg.textContent = warnings.join('\n');
    warningsArea.innerHTML=''; warningsArea.appendChild(wg);
  } else warningsArea.innerHTML='';

  // Show download button now (always available because we created a blob)
  const url = await writer.getBlob();
  if (url) {
    fallbackBlobUrl = url;
    downloadBtn.style.display = 'inline-block';
    downloadBtn.disabled = false;
    downloadBtn.onclick = () => {
      const a = document.createElement('a');
      a.href = fallbackBlobUrl;
      let name = (outnameInput.value||'nrrel-mapping').trim(); if (!/\.csv$/i.test(name)) name += '.csv';
      a.download = name; document.body.appendChild(a); a.click(); a.remove();
    };
  }

  processBtn.disabled = false;
}

// attach
processBtn.addEventListener('click', ()=>{ processAll().catch(e=>{ logWarn('Processing error: '+(e&&e.message?e.message:String(e))); processBtn.disabled=false; }); });

// init
logInfo('Ready. Select files to enable processing.');
</script>
</body>
</html>
