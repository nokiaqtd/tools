<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>Partitur Reader — Mobile Landscape (patched)</title>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.*/css/pico.min.css">
    <style>
        /* standard UI blue for this file */
        :root {
            --ui-blue: #1e90ff;
        }

        /* --- Zoom slider / thumb --- */
        /* Target explicit IDs and common class names for safety */
        #zoomSlider,
        input[type="range"].zoom,
        .range.zoom,
        .zoom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 180px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.06);
            /* subtle background so thumb stands out on white */
            outline: none;
            vertical-align: middle;
        }

        /* track fill (WebKit) - make the filled part of the track use the standard blue */
        #zoomSlider::-webkit-slider-runnable-track,
        input[type="range"].zoom::-webkit-slider-runnable-track {
            border-radius: 999px;
            background: linear-gradient(90deg, var(--ui-blue) 0%, var(--ui-blue) 100%);
            box-shadow: none;
        }

        /* thumb */
        #zoomSlider::-webkit-slider-thumb,
        input[type="range"].zoom::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            border-radius: 50%;
            background: var(--ui-blue);
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(30, 144, 255, 0.16);
            cursor: pointer;
        }

        /* Firefox thumb */
        #zoomSlider::-moz-range-thumb,
        input[type="range"].zoom::-moz-range-thumb {
            border-radius: 50%;
            background: var(--ui-blue);
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(30, 144, 255, 0.16);
        }

        /* Firefox track */
        #zoomSlider::-moz-range-track,
        input[type="range"].zoom::-moz-range-track {
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.06);
        }

        /* --- Zoom label / value --- */
        #zoomLabel,
        label[for="zoomSlider"],
        .zoom-value,
        .zoomLabel {
            color: var(--ui-blue);
            font-weight: 600;
            font-size: 13px;
            margin-left: 6px;
            vertical-align: middle;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.8);
            /* tiny lift on white */
        }

        /* If label sits inside a control row, make sure it is readable on white */
        .control-row {
            background: transparent;
        }

        /* --- #fileLabel reposition + styling --- */
        #fileLabel {
            position: absolute !important;
            bottom: 2px !important;
            right: 2px !important;
            color: var(--ui-blue) !important;
            /* background: rgba(255,255,255,0.92); */
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.06);
            pointer-events: none;
            /* non-interactive */
            z-index: 50;
        }

        #recTimer {
            position: absolute !important;
            bottom: 28px !important;
            right: 2px !important;
            font-size: 13px;
            /* color: var(--ui-blue); */
            /* background: rgba(255,255,255,0.92); */
        }

        /* If there is an icon or small filename trimming, keep it compact */
        #fileLabel .name {
            max-width: 480px;
            display: inline-block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* --- Hide view button (common selectors included) --- */
        #viewButton,
        .view-button,
        .btn-view,
        .viewBtn {
            display: none !important;
        }

        /* --- Optional small responsive tweak so slider doesn't overflow small containers --- */
        @media (max-width: 420px) {

            #zoomSlider,
            input[type="range"].zoom {
                width: 120px;
            }
        }
    </style>

    <style>
        :root {
            --ui-gap: 8px;
            --state-pill-bg: rgba(0, 0, 0, 0.5);
            --state-pill-color: #fff;
            --accent: #0066ff;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b1220;

        }

        /* make pages full screen */

        .page {
            position: fixed;
            /* full-screen layer */
            inset: 0;
            /* top:0; right:0; bottom:0; left:0 */
            height: calc(var(--vh, 1vh) * 100);
            /* robust: uses JS-set --vh */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
            /* prevent content from pushing height unexpectedly */
        }

        /* Top controls area — hidden (we use overlay buttons) */
        .controls {
            display: none;
            /* hidden as requested */
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.02);
            padding: 8px;
            border-radius: 10px;
        }

        .controls .group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .controls label {
            font-size: 0.9rem;
            color: #cfe2ff;
        }

        .btn-primary {
            background: linear-gradient(180deg, var(--accent), #0047b3);
            color: white;
        }

        .btn {
            transition: transform 120ms ease, box-shadow 120ms ease;
        }

        .btn:active {
            transform: translateY(1px) scale(0.995);
            box-shadow: none;
        }

        /* Preview area fills remaining space */
        .preview-wrap {
            flex: 1 1 auto;
            display: block;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.5));
        }

        .preview-canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            position: relative;
            overflow: hidden;
        }

        .preview-canvas img {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
            user-select: none;
            -webkit-user-drag: none;
            max-width: none;
        }

        /* Overlay small buttons (top-left) */
        .overlay-buttons {
            position: absolute;
            bottom: 5px;
            left: 5px;
            display: flex;
            gap: 8px;
            z-index: 50;
            pointer-events: auto;
        }

        .ov-btn {
            padding: 6px 8px;
            font-size: 0.82rem;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.55);
            color: #e8f1ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
            min-width: 66px;
        }

        .ov-btn:active {
            transform: translateY(1px);
        }

        /* bottom controls fixed at bottom of setup page */
        .bottom-controls {
            position: fixed;
            left: 8px;
            right: 8px;
            bottom: env(safe-area-inset-bottom, 8px);
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 9999;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.0), rgba(0, 0, 0, 0.06));
            padding: 6px 8px;
            border-radius: 8px;
        }

        /* small horizontal zoom slider */
        .zoom-slider {
            width: 120px;
            height: 34px;
            margin: 0;
            background: transparent;
        }

        .zoom-slider::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.08);
        }

        .zoom-slider::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-top: -4px;
            background: #fff;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }

        .zoom-slider:focus {
            outline: none;
        }


        .view-controls {
            position: fixed;
            left: 8px;
            /* anchor to left */
            bottom: env(safe-area-inset-bottom, 8px);
            /* bottom */
            display: flex;
            justify-content: flex-start;
            /* no centering */
            align-items: center;
            gap: 8px;
            z-index: 55;
        }

        .view-controls .btn {
            min-width: auto;
            /* width = content */
            padding: 6px 10px;
            /* smaller button look */
            font-size: 0.82rem;
        }

        /* View page */
        .view-wrap {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: black;
        }

        .view-canvas {
            position: fixed;
            /* full-screen layer */
            inset: 0;
            /* top:0; right:0; bottom:0; left:0 */
            height: calc(var(--vh, 1vh) * 100);
            /* robust: uses JS-set --vh */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
            /* prevent content from pushing height unexpectedly */
        }

        .view-canvas img {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
            max-width: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* state pill */
        .state-pill {
            position: fixed;
            bottom: 8px;
            right: 12px;
            background: var(--state-pill-bg);
            color: var(--state-pill-color);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.95rem;
            z-index: 60;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        .hint {
            position: absolute;
            bottom: 54px;
            right: 12px;
            z-index: 11;
            color: #c8d8ff;
            background: rgba(0, 0, 0, 0.35);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .timer-badge {
            display: inline-block;
            min-width: 48px;
            text-align: center;
            background: rgba(255, 255, 255, 0.06);
            color: #eaf2ff;
            padding: 6px 8px;
            border-radius: 8px;
            font-weight: 600;
        }

        .small-muted {
            font-size: 0.85rem;
            color: #aab9d9;
        }

        @media (orientation:landscape) {
            .controls {
                padding: 10px;
            }
        }


        /* side buttons centered vertically left/right (fixed to viewport) */
        .side-btn {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            padding: 10px 14px;
            z-index: 99999;
            background: rgba(0, 0, 0, 0.65);
            color: #eaf2ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            font-weight: 700;
            white-space: nowrap;
            width: auto;
            min-width: 0;
            pointer-events: auto;
        }

        .side-right {
            right: 10px;
        }

        .side-left {
            left: 10px;
        }

        /* timer variants */
        .timer-badge.recording {
            background: rgba(200, 40, 40, 0.95);
            color: #fff;
        }

        .timer-badge.paused {
            background: rgba(255, 255, 255, 0.06);
            color: #eaf2ff;
        }

        .timer-badge.replay {
            background: rgba(18, 98, 200, 0.95);
            color: #fff;
        }

        #replayBlinkLine {
            background: #000;
            opacity: 1;
        }

        /* fade cover already inline-styled; optionally tune: */
        #replayFadeCover {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <!-- Setup Page (full screen) -->
    <section id="setupPage" class="page" aria-label="Setup Page">
        <div class="controls" role="region" aria-label="Controls">
            <!-- Hidden top controls (kept for backward compatibility) -->
            <div class="group">
                <button id="btnLoad" class="btn">Load File</button>
                <label for="rememberFolder" style="margin-left:6px">Remember folder</label>
                <input type="checkbox" id="rememberFolder"
                    title="Allow remembering folder (uses File System Access API)">
            </div>

            <div class="group">
                <label>Duration (s)</label>
                <input id="inpDuration" type="number" min="0.1" value="15" step="0.1" />
            </div>
            <div class="group">
                <label>Delay (s)</label>
                <input id="inpDelay" type="number" min="0" value="1" step="0.1" />
            </div>
            <div class="group">
                <label>Y down %</label>
                <input id="inpYdown" type="number" min="0" max="100" value="100" step="1" />
            </div>

            <div class="group" style="margin-left:auto">
                <button id="btnRecord" class="btn btn-primary">Record</button>
                <button id="btnOpenView" class="btn">Open View</button>
            </div>
        </div>

        <div class="preview-wrap" id="previewWrap" style="margin-top:8px;">
            <div class="preview-canvas" id="previewCanvas">
                <img id="previewImg" alt="preview" src="" draggable="false" />

                <!-- center-right Next button (shown during recording) -->
                <button id="btnNext" class="side-btn side-right" hidden>Next</button>

                <!-- center-left Continue button (shown after Next) -->
                <button id="btnContinue" class="side-btn side-left" hidden>Continue</button>

                <!-- RECORD PROMPT (Add this inside #previewCanvas) -->
                <div id="recordPrompt" style="
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 99999;
                    background: rgba(0,0,0,0.78);
                    color: #fff;
                    padding: 12px 16px;
                    border-radius: 10px;
                    font-weight: 700;
                    display: none;
                    text-align: center;
                    max-width: 92%;
                    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
                ">Please select row 1 then click "Continue"</div>

            </div>

        </div>

        <div class="bottom-controls">
            <!-- overlay small buttons -->
            <div class="overlay-buttons" id="overlayButtons">
                <button id="overlayLoad" class="ov-btn">Load</button>
                <button id="overlayRecord" class="ov-btn">Record</button>
                <button id="overlayReplay" class="ov-btn" hidden>Replay</button>


                <button id="overlayOpenView" class="ov-btn" hidden>View</button>
                <button id="overlayRotate" class="ov-btn" hidden>Rotate</button>
                <!-- Zoom slider placed next to View button -->
                <label for="zoomSlider" class="small-muted"
                    style="margin:6px 6px 0 6px; font-size:0.82rem;">Zoom</label>
                <input id="zoomSlider" class="zoom-slider" type="range" min="0.25" max="4" step="0.01" value="1"
                    title="Zoom" />
            </div>

            <div style="margin-left:auto" class="small-muted" id="fileLabel">No file loaded</div>
            <div style="margin-left:8px" id="recTimer" class="timer-badge" aria-live="polite">0.0s</div>
            <button id="btnManage" class="btn" hidden>Manage saved files</button>
        </div>
    </section>

    <!-- View Page (full screen) -->
    <section id="viewPage" class="view-wrap" aria-hidden="true">
        <div class="view-canvas" id="viewCanvas">
            <img id="viewImg" alt="view" src="" draggable="false" />
        </div>
        <div class="view-controls" id="viewControls">
            <button id="btnViewBack" class="btn">Back </button>
            <button id="btnViewToggle" class="btn btn-primary">Play</button>
            <div class="state-pill" id="statePill">Ready</div>
            <div class="hint" id="hint" hidden>Tap left/right when at end to move up/down</div>

        </div>
    </section>

    </section>


    <script>
        /* Partitur Reader — patched to requested behavior
           - Overlay small buttons: Load, Record, View, Rotate
           - Zoom slider removed
           - Rotation added (90° steps)
           - Record timestamps: touchRecordTime, firstPanTime, stopTime
           - View enters Paused state so user can position start
           - Resume logic: if hOffset ≈ startOffsetX then add delay, else compute remaining seconds using speed
        */

        // ======= Configuration =======
        const DB_NAME = 'scoreReaderDB';
        const STORE_FILES = 'files';
        const MAX_FILES = 300;
        const DEFAULTS = { duration: 15, delay: 1, ydownPercent: 100, zoom: 1.0 };

        // ======= Helpers =======
        function $(s, r = document) { return r.querySelector(s); }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function formatNumber(v) { return (Math.round(v * 100) / 100).toFixed(2); }
        function approxEqual(a, b, tol = 1) { return Math.abs(a - b) <= tol; }

        // ======= IndexedDB helpers (unchanged) =======
        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_FILES)) {
                        const s = db.createObjectStore(STORE_FILES, { keyPath: 'id' });
                        s.createIndex('lastUsed', 'lastUsed', { unique: false });
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbGet(id) {
            const db = await openDB(); return new Promise((res, rej) => {
                const tx = db.transaction(STORE_FILES, 'readonly'); const st = tx.objectStore(STORE_FILES);
                const r = st.get(id); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
            });
        }
        async function idbPut(rec) {
            const db = await openDB(); return new Promise((res, rej) => {
                const tx = db.transaction(STORE_FILES, 'readwrite'); const st = tx.objectStore(STORE_FILES);
                const r = st.put(rec); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
            });
        }
        async function idbDelete(id) {
            const db = await openDB(); return new Promise((res, rej) => {
                const tx = db.transaction(STORE_FILES, 'readwrite'); const st = tx.objectStore(STORE_FILES);
                const r = st.delete(id); r.onsuccess = () => res(); r.onerror = () => rej(r.error);
            });
        }
        async function pruneIfNeeded() {
            try {
                const db = await openDB(); const tx = db.transaction(STORE_FILES, 'readwrite'); const st = tx.objectStore(STORE_FILES);
                const idx = st.index('lastUsed'); const list = [];
                idx.openCursor().onsuccess = e => {
                    const cur = e.target.result; if (cur) { list.push({ id: cur.value.id, lastUsed: cur.value.lastUsed }); cur.continue(); } else {
                        if (list.length > MAX_FILES) { const removeCount = list.length - MAX_FILES; for (let i = 0; i < removeCount; i++) { st.delete(list[i].id); } }
                    }
                };
            } catch (e) { console.warn('prune failed', e); }
        }

        function fileIdFromFile(file) { if (!file) return null; return `${file.name}|${file.size}|${file.lastModified}`; }

        // ======= DOM refs =======
        const btnLoad = $('#btnLoad'), rememberFolder = $('#rememberFolder');
        const inpDuration = $('#inpDuration'), inpDelay = $('#inpDelay'), inpYdown = $('#inpYdown');
        const btnRecord = $('#btnRecord'), btnOpenView = $('#btnOpenView');
        const startLabel = $('#startLabel'), fileLabel = $('#fileLabel'), recTimer = $('#recTimer');
        const previewCanvas = $('#previewCanvas'), previewImg = $('#previewImg');
        const viewPage = $('#viewPage'), viewCanvas = $('#viewCanvas'), viewImg = $('#viewImg');
        const statePill = $('#statePill');
        const btnManage = $('#btnManage');
        const viewControls = $('#viewControls'), btnViewBack = $('#btnViewBack'), btnViewToggle = $('#btnViewToggle');

        // overlay buttons + zoom slider
        const overlayLoad = $('#overlayLoad'), overlayRecord = $('#overlayRecord'), overlayOpenView = $('#overlayOpenView'), overlayRotate = $('#overlayRotate');
        const zoomSlider = $('#zoomSlider');


        // --- front-layer image (duplicate) ---
        // Insert after the DOM refs where previewImg is declared.
        const previewImgFront = document.createElement('img');
        previewImgFront.id = 'previewImgFront';
        previewImgFront.alt = 'front';
        previewImgFront.draggable = false;
        previewImgFront.style.position = 'absolute';
        previewImgFront.style.top = '0';
        previewImgFront.style.left = '0';
        previewImgFront.style.transformOrigin = '0 0';
        previewImgFront.style.willChange = 'transform, clip-path';
        previewImgFront.style.pointerEvents = 'none'; // do not steal input
        previewImgFront.style.zIndex = '2'; // above previewImg
        previewImgFront.style.display = 'none'; // hidden until needed
        previewCanvas.appendChild(previewImgFront);

        // ensure the original back image sits beneath
        previewImg.style.zIndex = '1';


        // ======= App state =======
        let currentFile = null, fileHandle = null, fileId = null, currentObjectURL = null, dbRecord = null;
        

        let fileSettings = {
            startOffsetX: 0,
            startOffsetY: 0,
            startZoom: 1,
            duration: DEFAULTS.duration,
            delay: DEFAULTS.delay,
            ydownPercent: DEFAULTS.ydownPercent,
            zoom: DEFAULTS.zoom,
            // playback defaults — persisted to DB
            playbackspeed: 100,   // percent; 100 = normal
            autoplayback: false   // boolean
        };        
        // preview state
        let preview = { scale: DEFAULTS.zoom, hOffset: 0, vOffset: 0, imgW: 0, imgH: 0, containerW: 0, containerH: 0, dragging: false, lastPointer: null, lockVertical: false, lockZoom: false, rotation: 0 };

        // view state
        let viewState = { scale: 1, hOffset: 0, vOffset: 0, imgW: 0, imgH: 0, containerW: 0, containerH: 0, D_x: 0, D_y: 0, startOffsetX: 0, startOffsetY: 0, startZoom: 1, duration: DEFAULTS.duration, delay: DEFAULTS.delay, ydownPercent: DEFAULTS.ydownPercent, state: 'Setup', playReqId: null, _playStartTimestamp: 0, _hOffsetAtPlayStart: 0, vx: 0, rotation: 0 };

        // record workflow state
        let recordState = { mode: 'idle', timerHandle: null, countdown: 0, startTime: 0, stopTime: 0, preVOffset: 0, _delayTick: null, touchRecordTime: 0, firstPanTime: 0 };

        // front reveal state: becomes true once front is revealed to half (50%)
        // and stays true until the user explicitly taps/clicks to continue
        let frontAwaitingTap = false;

        // ======= Load file handling =======
        async function loadFile(file, handle = null) {
            if (currentObjectURL) { URL.revokeObjectURL(currentObjectURL); currentObjectURL = null; }
            currentFile = file; fileHandle = handle; fileId = fileIdFromFile(file);
            fileLabel.textContent = file.name || 'Unnamed file';
            currentObjectURL = URL.createObjectURL(file);
            previewImg.src = currentObjectURL; viewImg.src = currentObjectURL;
            previewImgFront.src = currentObjectURL; // keep duplicate in sync

            await previewImg.decode().catch(() => { });
            preview.imgW = previewImg.naturalWidth || 1; preview.imgH = previewImg.naturalHeight || 1;
            // set container dims
            const rect = previewCanvas.getBoundingClientRect();
            preview.containerW = rect.width; preview.containerH = rect.height;
            // default fit width zoom
            const fitZoom = preview.containerW / preview.imgW;
            preview.scale = clamp(fitZoom, 0.25, 4);
            preview.hOffset = 0; preview.vOffset = 0;
            preview.rotation = 0;
            viewState.rotation = 0;
            // load saved record if any
            const rec = await idbGet(fileId).catch(() => null);
            if (rec && rec.settings) {
                dbRecord = rec;
                fileSettings = Object.assign(fileSettings, rec.settings);
                inpDuration.value = fileSettings.duration || DEFAULTS.duration;
                inpDelay.value = fileSettings.delay || DEFAULTS.delay;
                inpYdown.value = fileSettings.ydownPercent || DEFAULTS.ydownPercent;
                preview.scale = fileSettings.startZoom || fileSettings.zoom || preview.scale;
                preview.hOffset = fileSettings.startOffsetX || 0;
                preview.vOffset = fileSettings.startOffsetY || 0;
                preview.rotation = fileSettings.rotation || 0;
            } else {
                inpDuration.value = fileSettings.duration;
                inpDelay.value = fileSettings.delay;
                inpYdown.value = fileSettings.ydownPercent;
                fileSettings.startZoom = preview.scale;
                fileSettings.startOffsetX = 0; fileSettings.startOffsetY = 0;
                fileSettings.rotation = 0;
            }
            updatePreviewTransform(true);

            // ensure zoom slider shows current preview.scale
            const zs = $('#zoomSlider');
            if (zs) zs.value = preview.scale;

            // show Replay only when both segments AND initials exist for this file
            try {
                overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length
                    && fileSettings.initials && fileSettings.initials.length);
            } catch (e) { /* ignore if overlayReplay not ready */ }

            saveRecord();
        }

        async function saveRecord() {
            if (!currentFile) return;
            // capture current screen & preview image dimensions
            const screenW = window.innerWidth || document.documentElement.clientWidth || 0;
            const screenH = window.innerHeight || document.documentElement.clientHeight || 0;
            const imgW = preview.imgW || 0;
            const imgH = preview.imgH || 0;

            // ensure playback keys exist (defensive)
            if (typeof fileSettings.playbackspeed === 'undefined') fileSettings.playbackspeed = 100;
            if (typeof fileSettings.autoplayback === 'undefined') fileSettings.autoplayback = false;

            const rec = {
                id: fileId,
                name: currentFile.name,
                size: currentFile.size,
                lastModified: currentFile.lastModified,
                handle: fileHandle || null,
                // persist settings (includes playbackspeed & autoplayback)
                settings: Object.assign({}, fileSettings, { rotation: preview.rotation }),
                // store screen & image dims for later use
                screenW: screenW,
                screenH: screenH,
                imgW: imgW,
                imgH: imgH,
                lastUsed: Date.now()
            };
            await idbPut(rec).catch(e => console.warn('save fail', e));
            await pruneIfNeeded();
        }


        // ======= File pickers =======
        async function openFilePicker() {
            if (window.showOpenFilePicker) {
                try {
                    const [fh] = await window.showOpenFilePicker({ multiple: false, types: [{ description: 'Image files', accept: { 'image/*': ['.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp'] } }] });
                    if (!fh) return;
                    const f = await fh.getFile();
                    await loadFile(f, fh);
                    return;
                } catch (e) { console.warn('openFilePicker', e); }
            }
            // fallback
            const inp = document.createElement('input'); inp.type = 'file'; inp.accept = 'image/*';
            inp.onchange = async () => { if (inp.files && inp.files[0]) await loadFile(inp.files[0], null); };
            inp.click();
        }

        // ======= Preview interactions (pointer events) =======
        let activePointers = new Map();
        previewCanvas.addEventListener('pointerdown', (e) => {
            if (isReplayActive()) return;
            previewCanvas.setPointerCapture(e.pointerId);
            activePointers.set(e.pointerId, e);

            if (activePointers.size === 1) {
                preview.dragging = true;
                preview.lastPointer = { x: e.clientX, y: e.clientY };
            } else if (activePointers.size === 2) {
                // prepare pinch base using the two active pointers
                const pts = Array.from(activePointers.values());
                preview._pinchBase = {
                    d: Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY),
                    scale: preview.scale
                };
            }
        });

        previewCanvas.addEventListener('pointermove', (e) => {
            // ignore any user input while replay is active
            if (isReplayActive()) return;

            if (!activePointers.has(e.pointerId)) return;
            activePointers.set(e.pointerId, e);

            // SINGLE POINTER: dragging
            if (activePointers.size === 1 && preview.dragging) {
                const p = preview.lastPointer || { x: e.clientX, y: e.clientY };
                const dx = e.clientX - p.x;
                const dy = e.clientY - p.y;
                // update last pointer
                preview.lastPointer = { x: e.clientX, y: e.clientY };

                // apply horizontal always, vertical only if not locked
                // note: you previously used preview.hOffset = preview.hOffset - dx
                preview.hOffset = preview.hOffset - dx;
                // if vertical locked, ignore any vertical change
                if (!preview.lockVertical) {
                    preview.vOffset = preview.vOffset - dy;
                }

                // ensure vOffset does not go out of bounds (basic clamp)
                // compute vertical max (image height scaled minus container height)
                try {
                    const imgHeightScaled = ((preview.rotation % 180) !== 0 ? preview.imgW : preview.imgH) * preview.scale;
                    const maxV = Math.max(0, imgHeightScaled - preview.containerH);
                    preview.vOffset = clamp(preview.vOffset, 0, maxV);
                } catch (err) {
                    // if preview properties not ready, ignore
                }

                // Recording metadata: detect first meaningful horizontal pan
                if (recordState.mode === 'recording' && recordState.phase === 'captureSegments') {
                    if (!recordState.firstPanTime && Math.abs(dx) > 0.5) {
                        recordState.firstPanTime = performance.now();
                        recordState.firstPanHOffset = preview.hOffset;
                    }
                    recordState.lastPanHOffset = preview.hOffset;
                }


                updatePreviewTransform();
                return;
            }

            // TWO POINTERS: pinch-to-zoom
            if (activePointers.size === 2) {
                if (preview.lockZoom) return; // zoom locked during recording/replay as required
                const pts = Array.from(activePointers.values());
                const d = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
                const base = preview._pinchBase;
                if (base && base.d > 0) {
                    const sf = d / base.d;
                    preview.scale = clamp(base.scale * sf, 0.25, 4);
                    updatePreviewTransform();
                }
                return;
            }
        });

        previewCanvas.addEventListener('pointerup', (e) => {
            activePointers.delete(e.pointerId);
            try { previewCanvas.releasePointerCapture(e.pointerId); } catch (err) { }
            if (activePointers.size === 0) {
                preview.dragging = false;
                preview._pinchBase = null;
                preview.lastPointer = null;
            } else if (activePointers.size === 1) {
                // if one pointer left, reset lastPointer to the remaining pointer so movement continues smoothly
                const remaining = Array.from(activePointers.values())[0];
                preview.lastPointer = { x: remaining.clientX, y: remaining.clientY };
            }
        });


        previewCanvas.addEventListener('pointercancel', (e) => { activePointers.delete(e.pointerId); preview.dragging = false; preview._pinchBase = null; preview.lastPointer = null; });

        // compute scaled W/H based on rotation
        function scaledDimsForPreview() {
            const rot = ((preview.rotation % 360) + 360) % 360;
            const is90 = (rot === 90 || rot === 270);
            const scaledW = (is90 ? preview.imgH : preview.imgW) * preview.scale;
            const scaledH = (is90 ? preview.imgW : preview.imgH) * preview.scale;
            return { scaledW, scaledH };
        }

        function applyInitial(index) {
            if (!recordState.initials || index < 0 || index >= recordState.initials.length) return;
            const init = recordState.initials[index];
            preview.scale = (typeof init.scale !== 'undefined') ? init.scale : preview.scale;
            preview.hOffset = init.hOffset || 0;
            preview.vOffset = init.vOffset || 0;
            updatePreviewTransform();
        }

        // --- REC TIMER HELPERS (ADD) ---
        function _formatSec(s) {
            // format to 2 decimal seconds, e.g. "1.23s"
            return (Math.round(s * 100) / 100).toFixed(2) + 's';
        }

        function startRecTimer() {
            // stop any existing loop first
            stopRecTimer();
            recordState.recTimerRunning = true;
            function tick() {
                if (!recordState.recTimerRunning) return;
                const el = document.querySelector('#recTimer');
                if (!el) { recordState.recTimerRaf = requestAnimationFrame(tick); return; }

                let t = 0;
                // If capturing segments: before first pan -> show delay (now - startTime)
                // after first pan -> show duration (now - firstPanTime)
                if (recordState.phase === 'captureSegments') {
                    if (recordState.firstPanTime && recordState.firstPanTime > 0) {
                        t = (performance.now() - recordState.firstPanTime) / 1000;
                    } else if (recordState.startTime) {
                        t = (performance.now() - recordState.startTime) / 1000;
                    } else {
                        t = 0;
                    }
                } else {
                    // fallback: show time since startTime
                    if (recordState.startTime) t = (performance.now() - recordState.startTime) / 1000;
                }

                el.textContent = _formatSec(t);
                recordState.recTimerRaf = requestAnimationFrame(tick);
            }
            recordState.recTimerRaf = requestAnimationFrame(tick);
        }

        function stopRecTimer() {
            recordState.recTimerRunning = false;
            if (recordState.recTimerRaf) {
                cancelAnimationFrame(recordState.recTimerRaf);
                recordState.recTimerRaf = null;
            }
        }


        // update preview transform and ensure viewport never shows blank on right or left
        function updatePreviewTransform(skipClamp = false) {
            const rect = previewCanvas.getBoundingClientRect();
            preview.containerW = rect.width; preview.containerH = rect.height;
            const dims = scaledDimsForPreview();
            const scaledW = dims.scaledW;
            const scaledH = dims.scaledH;
            const D_x = Math.max(0, scaledW - preview.containerW);
            const D_y = Math.max(0, scaledH - preview.containerH);
            preview.hOffset = clamp(preview.hOffset, 0, D_x);
            preview.vOffset = clamp(preview.vOffset, 0, D_y);
            // apply transform: translate then rotate then scale
            previewImg.style.transform = `translate3d(${-Math.round(preview.hOffset)}px, ${-Math.round(preview.vOffset)}px, 0) rotate(${preview.rotation}deg) scale(${preview.scale})`;
        }

        // ======= Overlay button wiring (forward to existing handlers) =======
        overlayLoad.addEventListener('click', () => btnLoad.click());
        overlayRecord.addEventListener('click', () => btnRecord.click());
        overlayOpenView.addEventListener('click', () => btnOpenView.click());
        overlayRotate.addEventListener('click', () => {
            // rotate preview and view by +90°
            preview.rotation = (preview.rotation + 90) % 360;
            viewState.rotation = preview.rotation;
            // recompute offsets to clamp
            updatePreviewTransform(true);
            // apply rotation for view preview (if view open)
            if (viewPage.style.display === 'block') {
                // recalc view dims and apply
                const rect = viewCanvas.getBoundingClientRect();
                viewState.containerW = rect.width; viewState.containerH = rect.height;
                viewState.rotation = preview.rotation;
                enterView_recalcAndApply();
            }
            // persist in settings
            fileSettings.rotation = preview.rotation;
            saveRecord();
        });

        // --- Zoom slider wiring (if present) ---
        if (zoomSlider) {
            // initialize slider with current preview scale (or default)
            try { zoomSlider.value = (preview && preview.scale) ? preview.scale : (typeof DEFAULTS !== 'undefined' ? DEFAULTS.zoom : 1); } catch (e) { }

            // live update while dragging
            zoomSlider.addEventListener('input', (e) => {
                const val = Number(e.target.value) || 1;
                // keep within allowed range
                preview.scale = clamp ? clamp(val, 0.25, 4) : Math.max(0.25, Math.min(4, val));
                updatePreviewTransform();
            });

            // on change (mouseup / touchend) persist into fileSettings and save
            zoomSlider.addEventListener('change', (e) => {
                fileSettings.startZoom = Number(e.target.value) || preview.scale;
                if (typeof saveRecord === 'function') saveRecord();
            });
        }


        // file load button (both top hidden one and overlay forwarded)
        btnLoad.addEventListener('click', async () => { await openFilePicker(); });

        // remember folder (same as before)
        rememberFolder.addEventListener('change', async () => {
            if (rememberFolder.checked && window.showDirectoryPicker) {
                try {
                    const dir = await window.showDirectoryPicker();
                    const rec = { id: 'DIR|' + (dir.name || 'unknown'), name: dir.name, handle: dir, settings: {}, lastUsed: Date.now() };
                    await idbPut(rec);
                    alert('Folder remembered.');
                } catch (err) { console.warn(err); rememberFolder.checked = false; alert('Could not remember folder.'); }
            }
        });

        // Manage saved files (simple prompt)
        btnManage.addEventListener('click', async () => {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_FILES, 'readonly'); const st = tx.objectStore(STORE_FILES);
                const items = []; st.openCursor().onsuccess = e => {
                    const cur = e.target.result; if (cur) { items.push(cur.value); cur.continue(); } else {
                        if (!items.length) return alert('No saved files');
                        const txt = items.map(it => `${it.id} (lastUsed: ${new Date(it.lastUsed).toLocaleString()})`).join('\\n');
                        const choice = prompt('Saved files:\\n\\n' + txt + '\\n\\nType exact id to delete or leave empty');
                        if (choice) { idbDelete(choice).then(() => alert('Deleted ' + choice)).catch(() => alert('Delete failed')); }
                    }
                };
            } catch (err) { alert('Manage failed: ' + err); }
        });

        // Use as start label update
        // function updateStartLabel(){ startLabel.textContent = `Start: x=${Math.round(fileSettings.startOffsetX||0)}, y=${Math.round(fileSettings.startOffsetY||0)}, zoom=${formatNumber(fileSettings.startZoom||fileSettings.zoom||preview.scale)}`; }

        // ======= Record + Replay workflow (new implementation) =======

        // extra DOM refs
        const btnNext = $('#btnNext'), btnContinue = $('#btnContinue'), overlayReplay = $('#overlayReplay');

        // REPLACE existing recordState declaration with this block
        recordState = Object.assign(recordState, {
            segments: [],         // completed segments: {delay, duration, ydownPercent, startHOffset, endHOffset, speedPxPerSec}
            currentSegment: null, // temp segment while waiting for Continue
            initials: [],         // array of initial positions captured at Record and after each Continue [{hOffset,vOffset,hPct,vPct}]
            startTime: 0,
            firstPanTime: 0,
            firstPanHOffset: 0,
            lastPanHOffset: 0,
            preVOffsetAtNext: 0,
            _timerInterval: null,
            replaying: false,
            pausedReplay: false,
            mode: 'idle'
        });



        // helper to update recTimer text & classes
        function setRecTimerText(text, cls) {
            recTimer.textContent = text;
            recTimer.classList.remove('recording', 'paused', 'replay');
            if (cls) recTimer.classList.add(cls);
        }

        // make preview ignore pointer input during replay
        // Replace previous isReplayActive() with this
        function isReplayActive() {
            // input should be disabled when actively replaying AND not paused.
            // When paused (pausedReplay === true) we allow user panning/interaction.
            return !!recordState.replaying && !recordState.pausedReplay;
        }


        // small safety: if pointer handlers exist elsewhere, honor this flag
        // patch pointer handlers to respect replay lock (insert these checks into your pointer handlers)
        // (see note below where to modify pointerdown/pointermove)

        /* --- recording flow --- */
        // ---------- Record / initial-collection / segment-capture flow ----------
        btnRecord.addEventListener('click', () => {
            if (!currentFile) return alert('Load a file first');

            // helper to show/hide prompt
            const showPrompt = (txt) => { const p = $('#recordPrompt'); if (p) { p.textContent = txt; p.style.display = 'block'; } };
            const hidePrompt = () => { const p = $('#recordPrompt'); if (p) p.style.display = 'none'; };

            // START RECORDING: entering initial-collection mode
            if (recordState.mode === 'idle' || recordState.mode === undefined) {
                // reset recordState for a fresh session
                recordState.mode = 'recording';
                recordState.phase = 'collectInitials';     // two phases: 'collectInitials' | 'captureSegments'
                recordState.initials = [];                 // will hold {hOffset,vOffset,scale,hPct,vPct}
                recordState.segments = [];                 // segments will be filled after capture
                recordState.currentRow = 1;                // 1-based row counter while collecting initials
                recordState.segmentIndex = -1;             // not yet in captureSegments
                recordState.startTime = performance.now(); // used later for delay/duration calculation
                recordState.firstPanTime = 0;
                recordState.firstPanHOffset = 0;
                recordState.lastPanHOffset = 0;
                recordState.currentSegment = null;

                // UI: allow user to position & zoom for the first initial
                preview.lockZoom = false;      // allow zoom BEFORE first Continue
                preview.lockVertical = false;
                overlayRecord.textContent = 'Stop';
                btnNext.hidden = false;
                btnContinue.hidden = false;
                btnContinue.textContent = 'Continue';
                btnNext.textContent = 'Next';

                // show center prompt
                showPrompt(`Please select row ${recordState.currentRow} then click "Continue"`);

                // small timer UX
                setRecTimerText('collect initial', 'recording');

                return;
            }

            // STOP RECORDING: finalize any pending segment/initial then persist & exit
            if (recordState.mode === 'recording') {
                // finalize any pending currentSegment if present (this logic mirrors earlier stop behavior)
                if (recordState.currentSegment) {
                    try {
                        const delta = Math.abs((preview.vOffset || 0) - (recordState.preVOffsetAtNext || 0));
                        const percent = (delta / preview.containerH) * 100;
                        recordState.currentSegment.ydownPercent = Math.round(percent * 100) / 100;
                    } catch (e) {
                        recordState.currentSegment.ydownPercent = 0;
                    }
                    recordState.segments.push(recordState.currentSegment);
                    recordState.currentSegment = null;

                    // capture a following initial for alignment (current preview pos)
                    recordState.initials.push({
                        hOffset: preview.hOffset || 0,
                        vOffset: preview.vOffset || 0,
                        scale: preview.scale || 1,
                        hPct: Math.round(((preview.hOffset || 0) / Math.max(1, preview.containerW)) * 10000) / 100,
                        vPct: Math.round(((preview.vOffset || 0) / Math.max(1, preview.containerH)) * 10000) / 100
                    });
                } else if (recordState.firstPanTime) {
                    // single-row segment case (user panned but never used Next)
                    const now = performance.now();
                    const duration = Math.max(0, now - recordState.firstPanTime) / 1000;
                    const delay = Math.max(0, recordState.firstPanTime - (recordState.startTime || recordState.firstPanTime)) / 1000;
                    const startH = recordState.firstPanHOffset || 0;
                    const endH = recordState.lastPanHOffset || preview.hOffset || startH;
                    const deltaPx = Math.abs(endH - startH);
                    const speedPxPerSec = duration > 0 ? deltaPx / duration : 0;

                    recordState.segments.push({
                        delay: Math.round(delay * 100) / 100,
                        duration: Math.round(duration * 100) / 100,
                        ydownPercent: 0,
                        startHOffset: startH,
                        endHOffset: endH,
                        speedPxPerSec: Math.round(speedPxPerSec * 100) / 100
                    });

                    // capture current preview as next initial
                    recordState.initials.push({
                        hOffset: preview.hOffset || 0,
                        vOffset: preview.vOffset || 0,
                        scale: preview.scale || 1,
                        hPct: Math.round(((preview.hOffset || 0) / Math.max(1, preview.containerW)) * 10000) / 100,
                        vPct: Math.round(((preview.vOffset || 0) / Math.max(1, preview.containerH)) * 10000) / 100
                    });
                }

                recordState.mode = 'idle';
                recordState.phase = 'idle';
                preview.lockZoom = false;
                preview.lockVertical = false;
                overlayRecord.textContent = 'Record';
                btnNext.hidden = true;
                btnContinue.hidden = true;

                // stop the rec timer RAF loop and reset UI badge
                stopRecTimer();
                setRecTimerText('0.0s', 'paused');


                // persist both segments and initials to fileSettings & DB
                try {
                    fileSettings.segments = recordState.segments.slice();
                    fileSettings.initials = recordState.initials.slice();
                } catch (e) { /* ignore */ }
                if (typeof saveRecord === 'function') saveRecord();

                overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length);

                // hide prompt
                hidePrompt();
                return;
            }
        });



        // REPLACE existing btnNext click handler with this block
        btnNext.addEventListener('click', () => {
            if (recordState.mode !== 'recording') return;

            // If we are still collecting initials, Next means "stop collecting and start capturing segments"
            if (recordState.phase === 'collectInitials') {
                // if user never pressed Continue for any initial yet -> capture current as initial[0]
                if (!recordState.initials.length) {
                    recordState.initials.push({
                        hOffset: preview.hOffset || 0,
                        vOffset: preview.vOffset || 0,
                        scale: preview.scale || 1,
                        hPct: Math.round(((preview.hOffset || 0) / Math.max(1, preview.containerW)) * 10000) / 100,
                        vPct: Math.round(((preview.vOffset || 0) / Math.max(1, preview.containerH)) * 10000) / 100
                    });
                    // lock zoom after first captured initial
                    preview.lockZoom = true;

                }

                // switch to captureSegments phase
                recordState.phase = 'captureSegments';
                recordState.segmentIndex = 0;
                recordState.startTime = performance.now();
                recordState.firstPanTime = 0;
                recordState.firstPanHOffset = 0;
                recordState.lastPanHOffset = 0;


                recordState.startTime = performance.now();
                preview.lockVertical = true;
                startRecTimer();               // begin/reset rec timer measuring delay for this row


                // UI: hide continue (no longer used) and keep Next visible for segment finalization
                btnContinue.hidden = true;
                btnNext.hidden = false;
                setRecTimerText('0.0s', 'recording');

                // move preview to initial of row 1
                applyInitial(0);

                // keep vertical pan enabled and keep the prompt invisible for the new row                
                const p = $('#recordPrompt'); if (p) p.style.display = 'none';

                // // update prompt to show we are now capturing segments
                // const p = $('#recordPrompt'); if (p) p.textContent = `Capturing segment for row 1 — pan to record, then click "Next"`;
                return;
            }

            // If we are in captureSegments: Next means finalize the current segment and move to next initial
            if (recordState.phase === 'captureSegments') {
                // ensure some panning happened (firstPanTime may be set by pointermove)
                if (!recordState.firstPanTime) {
                    // no pan detected yet; treat duration as 0 and set start/end to current h
                    // but we still progress to next row to avoid blocking
                }
                const now = performance.now();
                const duration = recordState.firstPanTime ? Math.max(0, now - recordState.firstPanTime) / 1000 : 0;
                const delay = recordState.firstPanTime ? Math.max(0, recordState.firstPanTime - (recordState.startTime || recordState.firstPanTime)) / 1000 : 0;
                const startH = recordState.firstPanHOffset || 0;
                const endH = recordState.lastPanHOffset || preview.hOffset || startH;
                const deltaPx = Math.abs(endH - startH);
                const speedPxPerSec = duration > 0 ? deltaPx / duration : 0;

                // create segment and push
                const seg = {
                    delay: Math.round(delay * 100) / 100,
                    duration: Math.round(duration * 100) / 100,
                    ydownPercent: 0, // will be computed when user adjusts vertical for next initial (if needed)
                    startHOffset: startH,
                    endHOffset: endH,
                    speedPxPerSec: Math.round(speedPxPerSec * 100) / 100
                };
                recordState.segments.push(seg);

                // compute ydown now using preVOffsetAtNext if any (the code path that previously used preVOffsetAtNext)
                try {
                    const delta = Math.abs((preview.vOffset || 0) - (recordState.preVOffsetAtNext || 0));
                    seg.ydownPercent = Math.round(((delta / preview.containerH) * 100) * 100) / 100;
                } catch (e) { seg.ydownPercent = 0; }

                // persist segment immediately
                try { fileSettings.segments = recordState.segments.slice(); } catch (e) { }
                if (typeof saveRecord === 'function') saveRecord();

                // move to next initial (if any)
                recordState.segmentIndex = (recordState.segmentIndex || 0) + 1;
                const nextIdx = recordState.segmentIndex;
                const nextInit = recordState.initials[nextIdx];

                if (nextInit) {
                    // move preview to next initial position + scale
                    preview.scale = (typeof nextInit.scale !== 'undefined') ? nextInit.scale : preview.scale;
                    preview.hOffset = nextInit.hOffset || 0;
                    preview.vOffset = nextInit.vOffset || 0;
                    updatePreviewTransform();

                    // reset timers for next row
                    recordState.startTime = performance.now();
                    recordState.firstPanTime = 0;
                    recordState.firstPanHOffset = 0;
                    recordState.lastPanHOffset = 0;
                    recordState.preVOffsetAtNext = preview.vOffset || 0;

                    // ensure rec timer restarts and vertical pan stays locked for the next capture
                    startRecTimer();
                    preview.lockVertical = true;

                    // update prompt
                    const p = $('#recordPrompt'); if (p) p.textContent = `Capturing segment for row ${nextIdx + 1} — pan to record, then click "Next"`;
                    setRecTimerText('0.0s', 'recording');
                    return;

                } else {
                    // no more initials — finish recording
                    recordState.mode = 'idle';
                    recordState.phase = 'idle';
                    preview.lockZoom = false;
                    preview.lockVertical = false;
                    overlayRecord.textContent = 'Record';
                    btnNext.hidden = true;
                    btnContinue.hidden = true;
                    setRecTimerText('0.0s', 'paused');

                    // persist final data
                    try { fileSettings.segments = recordState.segments.slice(); fileSettings.initials = recordState.initials.slice(); } catch (e) { }
                    if (typeof saveRecord === 'function') saveRecord();

                    const p = $('#recordPrompt'); if (p) { p.style.display = 'none'; }
                    overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length);

                    alert('Recording finished.');
                    return;
                }
            }
        });



        // Continue pressed: capture vertical difference (ydown) and prepare next cycle
        btnContinue.addEventListener('click', () => {
            // Only meaningful during initial-collection phase
            if (recordState.mode !== 'recording') return;
            if (recordState.phase === 'collectInitials') {
                // capture the current preview position as an initial for currentRow
                const h = preview.hOffset || 0, v = preview.vOffset || 0, sc = preview.scale || 1;
                recordState.initials.push({
                    hOffset: h,
                    vOffset: v,
                    scale: sc,
                    hPct: Math.round((h / Math.max(1, preview.containerW)) * 10000) / 100,
                    vPct: Math.round((v / Math.max(1, preview.containerH)) * 10000) / 100
                });

                // After first continue, lock zoom permanently for the session
                if (recordState.initials.length === 1) {
                    preview.lockZoom = true;
                }

                // persist progress
                try { fileSettings.initials = recordState.initials.slice(); } catch (e) { }
                if (typeof saveRecord === 'function') saveRecord();

                // increment row counter and update prompt
                recordState.currentRow = (recordState.currentRow || 1) + 1;
                const p = $('#recordPrompt');
                if (p) p.textContent = `Please select row ${recordState.currentRow} then click "Continue"`;

                // reset any timers related to segment capture (we are still collecting initials)
                setRecTimerText('collect initial', 'recording');
                return;
            }

            // If in captureSegments phase: Continue is not used (ignore)
        });



        // Helper: record first and last pan positions on pointermove (we will use these for delay/duration & speed)
        (function patchPointerHandlersForRecording() {
            // insert a guard into existing pointer handlers: if replay active -> ignore pointer events
            // Modify the beginning of your previewCanvas pointerdown handler to do:
            // if(isReplayActive()) return;
            // And modify pointermove similarly.
            // Below we only wire the recording-specific capture (non-destructive to your existing handler).
            previewCanvas.addEventListener('recording_internal_pointermove', () => { }); // noop marker

            // We rely on the existing pointermove which already updates preview.hOffset / vOffset.
            // So we only add a small listener to capture the recording timestamps.
            previewCanvas.addEventListener('pointermove', (e) => {
                // if replay is active, ignore user input here (do not change recorded timestamps)
                if (isReplayActive()) return;

                // only capture when actual dragging
                if (!activePointers.has(e.pointerId)) return;
                if (activePointers.size === 1 && preview.dragging) {
                    // detect first pan for a new recording segment
                    if (recordState.mode === 'recording' && recordState.phase === 'captureSegments' && !recordState.firstPanTime) {
                        recordState.firstPanTime = performance.now();
                        recordState.firstPanHOffset = preview.hOffset;
                    }

                    if (recordState.mode === 'recording') {
                        // always update lastPanHOffset to calculate speed if needed (end position)
                        recordState.lastPanHOffset = preview.hOffset;
                    }
                }
            });
        })();

        /* --- replay flow --- */

        // small helper to sleep while allowing pause/resume
        function sleepMs(ms) {
            return new Promise(resolve => {
                const start = performance.now();
                (function tick() {
                    if (recordState.pausedReplay) {
                        // poll until unpaused
                        setTimeout(tick, 120);
                        return;
                    }
                    const now = performance.now();
                    if (now - start >= ms) return resolve();
                    setTimeout(tick, 50);
                })();
            });
        }

        // animate property with RAF - returns promise
        // Replace previous animateProperty with this version.
        // It checks recordState.replayController.skipSegment to abort early.
        // Replace existing animateProperty with this version
        // Replace or update your animateProperty implementation to include this line:
        // pause-aware animateProperty
        function animateProperty(durationMs, onProgress) {
            return new Promise(resolve => {
                if (!recordState.replayController) recordState.replayController = { skipSegment: false, aborted: false };

                let elapsed = 0;                    // time progressed while NOT paused
                let lastTick = performance.now();   // last timestamp we observed

                function step() {
                    // abort conditions
                    if (!recordState.replaying || (recordState.replayController && recordState.replayController.aborted)) {
                        try { onProgress(1); } catch (e) { }
                        recordState.currentSegmentProgress = 1;
                        return resolve('aborted');
                    }

                    // skip-segment requested: complete immediately
                    if (recordState.replayController && recordState.replayController.skipSegment) {
                        try { onProgress(1); } catch (e) { }
                        recordState.replayController.skipSegment = false;
                        recordState.currentSegmentProgress = 1;
                        return resolve('skipped');
                    }

                    const now = performance.now();
                    // only accumulate elapsed while NOT paused
                    if (!recordState.pausedReplay) {
                        elapsed += (now - lastTick);
                    }
                    lastTick = now;

                    // compute progress from elapsed
                    const p = Math.min(1, elapsed / durationMs);
                    try { onProgress(p); } catch (e) { }

                    if (p >= 1) return resolve('done');
                    requestAnimationFrame(step);
                }

                requestAnimationFrame(step);
            });
        }


        // ---------- Front-layer helpers ----------
        function applyFrontInitial(nextInit) {
            if (!nextInit) {
                previewImgFront.style.display = 'none';
                return;
            }
            previewImgFront.style.display = 'block';
            // position/scale to match the saved initial (use preview.rotation for consistency)
            const sc = (typeof nextInit.scale !== 'undefined') ? nextInit.scale : (preview.scale || 1);
            const hx = typeof nextInit.hOffset !== 'undefined' ? nextInit.hOffset : 0;
            const vy = typeof nextInit.vOffset !== 'undefined' ? nextInit.vOffset : 0;
            previewImgFront.style.transform = `translate3d(${-Math.round(hx)}px, ${-Math.round(vy)}px, 0) rotate(${preview.rotation}deg) scale(${sc})`;
            // start fully hidden (clip-path: reveal from left by changing right inset)
            previewImgFront.style.clipPath = 'inset(0 100% 0 0)';
            previewImgFront.style.transition = '';
        }
        function showFrontFullyImmediate() {
            if (!previewImgFront || previewImgFront.style.display === 'none') return;
            previewImgFront.style.transition = 'clip-path 220ms ease';
            previewImgFront.style.clipPath = 'inset(0 0 0 0)';
            // after transition clear inline transition (caller may await ~230ms)
            setTimeout(() => { previewImgFront.style.transition = ''; }, 260);
        }
        function hideFront() {
            if (!previewImgFront) return;
            previewImgFront.style.display = 'none';
            previewImgFront.style.clipPath = 'inset(0 100% 0 0)';
        }



        async function startReplay() {
            fileSettings.playbackspeed = fileSettings.playbackspeed || 100;
            fileSettings.autoplayback = !!fileSettings.autoplayback;

            if (!fileSettings.segments || !fileSettings.segments.length) return alert('No recorded segments to replay.');
            // prepare UI + lock inputs
            recordState.replaying = true;
            recordState.pausedReplay = false;
            overlayReplay.textContent = 'Stop';
            overlayRecord.disabled = true;
            preview.lockZoom = true;
            preview.lockVertical = true;

            // create pause button if missing
            let btnPause = $('#overlayPause');
            if (!btnPause) {
                btnPause = document.createElement('button');
                btnPause.id = 'overlayPause';
                btnPause.className = 'ov-btn';
                btnPause.textContent = 'Pause';
                overlayReplay.parentNode.insertBefore(btnPause, overlayReplay.nextSibling);
            }
            btnPause.hidden = false;


            // --- overlay playback controls: wrapper, auto checkbox, rewind & fast-forward ---
            // show/create wrapper
            let pbWrapper = document.getElementById('overlayPBWrapper');
            if (!pbWrapper) {
                pbWrapper = document.createElement('div');
                pbWrapper.id = 'overlayPBWrapper';
                pbWrapper.style.position = 'fixed';
                pbWrapper.style.right = '8px';
                pbWrapper.style.bottom = '52px'; // above recTimer
                pbWrapper.style.zIndex = 999999;
                pbWrapper.style.display = 'flex';
                pbWrapper.style.flexDirection = 'column';
                pbWrapper.style.gap = '6px';
                pbWrapper.style.alignItems = 'flex-end';
                // no background on wrapper (transparent)
                pbWrapper.style.background = 'transparent';
                document.body.appendChild(pbWrapper);

                // Auto checkbox label
                const pbAuto = document.createElement('label');
                pbAuto.id = 'overlayPBAuto';
                pbAuto.style.display = 'flex';
                pbAuto.style.alignItems = 'center';
                pbAuto.style.gap = '6px';
                pbAuto.style.padding = '4px';
                pbAuto.style.background = 'transparent'; // transparent background
                pbAuto.style.color = ''; // inherit text color
                pbAuto.innerHTML = `<input id="overlayAutoChk" type="checkbox" style="margin:0 4px 0 0;"> Auto`;
                

                // row for buttons
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '6px';                
                pbWrapper.appendChild(row);
                row.prepend(pbAuto);
                
                const pbRew = document.createElement('button');
                pbRew.id = 'overlayPBRew';
                pbRew.className = 'ov-btn';
                pbRew.textContent = '◀◀';
                // transparent style (no visible background)
                pbRew.style.background = 'transparent';
                pbRew.style.border = 'none';
                pbRew.style.padding = '6px 8px';
                pbRew.style.fontSize = '14px';
                pbRew.style.cursor = 'pointer';
                row.appendChild(pbRew);

                const pbFwd = document.createElement('button');
                pbFwd.id = 'overlayPBFwd';
                pbFwd.className = 'ov-btn';
                pbFwd.textContent = '▶▶';
                pbFwd.style.background = 'transparent';
                pbFwd.style.border = 'none';
                pbFwd.style.padding = '6px 8px';
                pbFwd.style.fontSize = '14px';
                pbFwd.style.cursor = 'pointer';
                row.appendChild(pbFwd);


                // auto checkbox handler
                const chk = document.getElementById('overlayAutoChk');
                if (chk) {
                    chk.checked = !!fileSettings.autoplayback;
                    chk.addEventListener('change', (e) => {
                        fileSettings.autoplayback = !!e.target.checked;
                        if (typeof saveRecord === 'function') saveRecord();
                        const fl = document.getElementById('fileLabel'); if (fl) { const prev = fl.textContent; fl.style.color = 'red'; fl.textContent = fileSettings.autoplayback ? 'Auto ON' : 'Auto OFF'; setTimeout(()=>{ fl.style.color=''; fl.textContent = prev; }, 2000); }
                    });
                }
            } else {
                // make visible (if previously hidden)
                pbWrapper.style.display = 'flex';
                const chk = document.getElementById('overlayAutoChk');
                if (chk) chk.checked = !!fileSettings.autoplayback;
            }

            
            // --- create playback control UI (rewind / fast-forward + auto checkbox) ---
            let pbRew = $('#overlayPBRew'), pbFwd = $('#overlayPBFwd'), pbAuto = $('#overlayPBAuto');
            if (!pbRew) {
            // container wrapper: position right above #recTimer (absolute bottom-right)
            const wrapper = document.createElement('div');
            wrapper.id = 'overlayPBWrapper';
            wrapper.style.position = 'fixed';
            wrapper.style.right = '8px';
            wrapper.style.bottom = '52px'; // slightly above #recTimer
            wrapper.style.zIndex = 999999;
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '6px';
            wrapper.style.alignItems = 'flex-end';
            document.body.appendChild(wrapper);

            // create small buttons row first (so we can place auto inside it)
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.gap = '6px';
            row.style.alignItems = 'center';
            pbWrapper.appendChild(row);

            // auto checkbox + label — put inside the row so it appears left of rewind
            pbAuto = document.createElement('label');
            pbAuto.id = 'overlayPBAuto';
            pbAuto.style.display = 'flex';
            pbAuto.style.alignItems = 'center';
            pbAuto.style.gap = '6px';
            pbAuto.style.background = 'rgba(0,0,0,0.55)';
            pbAuto.style.padding = '6px';
            pbAuto.style.borderRadius = '8px';
            pbAuto.style.color = '#eaf2ff';
            pbAuto.innerHTML = `<input type="checkbox" id="overlayAutoChk" style="margin:0 4px 0 0;"> Auto`;
            // insert as the first item in the row (left of rewind)
            row.prepend(pbAuto);

            // rewind button (to the right of Auto)
            pbRew = document.createElement('button');
            pbRew.id = 'overlayPBRew';
            pbRew.className = 'ov-btn';
            pbRew.title = 'Slower (increase delays/durations)';
            pbRew.textContent = '◀◀';
            row.appendChild(pbRew);

            // forward button
            pbFwd = document.createElement('button');
            pbFwd.id = 'overlayPBFwd';
            pbFwd.className = 'ov-btn';
            pbFwd.title = 'Faster (decrease delays/durations)';
            pbFwd.textContent = '▶▶';
            row.appendChild(pbFwd);


            // save references for later
            pbRew = $('#overlayPBRew'); pbFwd = $('#overlayPBFwd'); pbAuto = $('#overlayPBAuto');
            }

            // show them
            if (pbRew) pbRew.hidden = false;
            if (pbFwd) pbFwd.hidden = false;
            if (pbAuto) pbAuto.style.display = 'flex';

            // Flash helper that resets the timeout on repeated clicks.
            // Shows `text` immediately and reverts to the real filename only ms after last call.
            let __fileLabelFlashTimeout = null;

            function flashPlaybackLabel(text, ms = 3000) {
                const fl = document.getElementById('fileLabel');
                if (!fl) return;

                // store original filename if not stored yet (do this once when a file is loaded)
                if (!fl.dataset.orig) {
                    // if you have currentFile set elsewhere, prefer that name:
                    if (typeof currentFile !== 'undefined' && currentFile && currentFile.name) {
                    fl.dataset.orig = currentFile.name;
                    } else {
                    fl.dataset.orig = fl.textContent || '';
                    }
                }

                // show temporary text
                fl.style.color = 'red';
                fl.textContent = text;

                // reset existing timer so repeated clicks keep the temporary text visible
                if (__fileLabelFlashTimeout) {
                    clearTimeout(__fileLabelFlashTimeout);
                }

                __fileLabelFlashTimeout = setTimeout(() => {
                    __fileLabelFlashTimeout = null;
                    fl.style.color = '';
                    // Always restore to the loaded filename (if available) or the original stored value
                    fl.textContent = fl.dataset.orig || '';
                }, ms);
            }


            // show current numeric playback speed for 3s when user presses replay
            flashPlaybackLabel(String(fileSettings.playbackspeed || 100) + '%', 3000);                    


            // --- playback step configuration (adjust step/min/max as you like) ---
            const PLAYBACK_STEP = 2;     // each click changes by 2%
            const PLAYBACK_MIN  = 20;     // lower bound
            const PLAYBACK_MAX  = 500;    // upper bound

            // Fast forward: INCREASE percent (bigger number = faster)
            pbFwd.addEventListener('click', () => {
            fileSettings.playbackspeed = Math.min(PLAYBACK_MAX, (fileSettings.playbackspeed || 100) + PLAYBACK_STEP);
            if (typeof saveRecord === 'function') saveRecord();
            flashPlaybackLabel(String(fileSettings.playbackspeed) + '%');
            });

            // Rewind / slow down: DECREASE percent (smaller number = slower)
            pbRew.addEventListener('click', () => {
            fileSettings.playbackspeed = Math.max(PLAYBACK_MIN, (fileSettings.playbackspeed || 100) - PLAYBACK_STEP);
            if (typeof saveRecord === 'function') saveRecord();
            flashPlaybackLabel(String(fileSettings.playbackspeed) + '%');
            });

            // auto checkbox wiring
            const chk = document.getElementById('overlayAutoChk');
            if (chk) {
            // initialize from fileSettings
            chk.checked = !!fileSettings.autoplayback;
            chk.addEventListener('change', (e) => {
                fileSettings.autoplayback = !!e.target.checked;
                if (typeof saveRecord === 'function') saveRecord();
                // briefly flash to show state
                flashFileLabelTemp(fileSettings.autoplayback ? 'Auto ON' : 'Auto OFF');
            });
            }



            // ensure replay controller
            recordState.replayController = { skipSegment: false, aborted: false };
            recordState.replayRecalcOnResume = false;

            // show timer style to replay (blue)
            setRecTimerText('0.0s', 'replay');

            const segments = fileSettings.segments.slice();
            const initials = (fileSettings.initials || []).slice();

            // create blink indicator element (2px vertical line at right)
            let blinkEl = document.getElementById('replayBlinkLine');
            if (!blinkEl) {
                blinkEl = document.createElement('div');
                blinkEl.id = 'replayBlinkLine';
                blinkEl.style.position = 'fixed';
                blinkEl.style.top = '0';
                blinkEl.style.right = '0';
                blinkEl.style.width = '2px';
                blinkEl.style.height = '100%';
                blinkEl.style.zIndex = 999999;
                blinkEl.style.pointerEvents = 'auto';
                blinkEl.style.display = 'none';
                document.body.appendChild(blinkEl);
            }

            // create fade cover for natural transition
            let fadeCover = document.getElementById('replayFadeCover');
            if (!fadeCover) {
                fadeCover = document.createElement('div');
                fadeCover.id = 'replayFadeCover';
                fadeCover.style.position = 'fixed';
                fadeCover.style.left = '0';
                fadeCover.style.top = '0';
                fadeCover.style.width = '100%';
                fadeCover.style.height = '100%';
                fadeCover.style.background = '#000';
                fadeCover.style.pointerEvents = 'none';
                fadeCover.style.zIndex = 999998;
                fadeCover.style.opacity = '0';
                fadeCover.style.transition = 'opacity 100ms linear';
                document.body.appendChild(fadeCover);
            }

            // helper: find index of initial closest to current preview.vOffset
            function findClosestInitialIndex() {
                if (!initials || !initials.length) return 0;
                let best = 0, bestDist = Infinity, curV = preview.vOffset || 0;
                for (let k = 0; k < initials.length; k++) {
                    const d = Math.abs((initials[k].vOffset || 0) - curV);
                    if (d < bestDist) { best = k; bestDist = d; }
                }
                return best;
            }

            // helper: show/hide blinking line with fast blinking animation
            let blinkHandler = null;
            function showBlink() {
                blinkEl.style.display = 'block';
                blinkEl.style.background = '#000';
                blinkEl.style.animation = 'replayBlink 240ms steps(2,start) infinite';
                // add click/tap handler to let user skip to next row or to resume "waiting" state
                blinkHandler = (ev) => {
                    ev.stopPropagation(); ev.preventDefault();
                    if (!recordState.replayController) recordState.replayController = {};
                    recordState.replayController.skipSegment = true;
                    // If replay is currently paused and waiting for user input, resolve that wait immediately.
                    if (recordState._resolveManualContinue) {
                        try { recordState._resolveManualContinue(); } catch (e) { }
                        recordState._resolveManualContinue = null;
                    }
                    hideBlink();
                };
                blinkEl.addEventListener('pointerdown', blinkHandler);
            }

            function hideBlink() {
                blinkEl.style.display = 'none';
                blinkEl.style.animation = '';
                if (blinkHandler) { blinkEl.removeEventListener('pointerdown', blinkHandler); blinkHandler = null; }
            }

            // keyframes for blink (inject style if not present)
            if (!document.getElementById('replayBlinkStyle')) {
                const s = document.createElement('style');
                s.id = 'replayBlinkStyle';
                s.textContent = `
      @keyframes replayBlink { 0% { opacity:1 } 50% { opacity:0 } 100% { opacity:1 } }
    `;
                document.head.appendChild(s);
            }

            // main loop
            for (let i = 0; i < segments.length; i++) {
                // if we need to recalc which index to play next (occurs after Resume)
                if (recordState.replayRecalcOnResume) {
                    const newIdx = findClosestInitialIndex();
                    // set loop index to newIdx
                    i = Math.max(0, newIdx);
                    recordState.replayRecalcOnResume = false;
                }

                const seg = segments[i];
                const init = (initials && initials[i]) ? initials[i] : null;

                // restore baseline from saved initials if available (preferred)
                if (init) {
                    preview.scale = (typeof init.scale !== 'undefined') ? init.scale : (preview.scale || 1);
                    preview.hOffset = (typeof init.hOffset !== 'undefined') ? init.hOffset : (seg.startHOffset || 0);
                    preview.vOffset = (typeof init.vOffset !== 'undefined') ? init.vOffset : (preview.vOffset || 0);
                } else {
                    preview.hOffset = seg.startHOffset || 0;
                }
                updatePreviewTransform();
                // prepare front-layer preview for the next row (duplicate of image, positioned at next initial)
                const nextInit = (initials && initials[i + 1]) ? initials[i + 1] : null;
                applyFrontInitial(nextInit);

                // if paused by user earlier, wait until resumed (this ensures resume recalc happens)
                while (recordState.pausedReplay && recordState.replaying) {
                    await new Promise(r => setTimeout(r, 100));
                }
                if (!recordState.replaying) break;

                // DELAY: if current preview.hOffset is already past startHOffset:
                // - if h <= startH: play delay normally
                // - if h between start and end: skip delay and compute remaining duration

                // apply playback speed factor from fileSettings (percent). 100 => normal (factor 1).
                // We want larger percent → faster playback, so invert the mapping: 200% => 0.5 (half duration).
                const playbackFactor = 100 / (fileSettings.playbackspeed || 100);

                const delayMs = Math.max(0, (seg.delay || 0)) * 1000 * playbackFactor;                
                const startH = (typeof seg.startHOffset !== 'undefined') ? seg.startHOffset : (preview.hOffset || 0);
                const endH = (typeof seg.endHOffset !== 'undefined') ? seg.endHOffset : startH;
                const curH = preview.hOffset || 0;

                // compute whether to play full delay
                if (curH <= startH) {
                    // play delay with timer

                    if (delayMs > 0) {
                        const start = performance.now();
                        let pausedAt = 0;
                        let pauseAccum = 0;

                        while (performance.now() - start - pauseAccum < delayMs) {
                            if (!recordState.replaying) break;

                            if (recordState.replayController && (recordState.replayController.skipSegment || recordState.replayController.aborted)) {
                                break;
                            }
                            if (recordState.replayRecalcOnResume) {
                                break;
                            }

                            if (recordState.pausedReplay) {
                                // start pause timestamp if not already paused
                                if (!pausedAt) pausedAt = performance.now();
                                // poll while paused
                                await new Promise(r => setTimeout(r, 100));
                                continue;
                            } else {
                                // if we were paused, accumulate the paused duration
                                if (pausedAt) {
                                    pauseAccum += (performance.now() - pausedAt);
                                    pausedAt = 0;
                                }
                            }

                            // show delay timer based on active (non-paused) elapsed
                            const activeElapsed = (performance.now() - start - pauseAccum);
                            setRecTimerText((activeElapsed / 1000).toFixed(1) + 's', 'replay');

                            await new Promise(r => setTimeout(r, 80));
                        }
                    }



                    if (!recordState.replaying) break;
                }
                // If curH > startH and curH < endH we will compute remaining duration below and animate only the remaining portion.
                if (!recordState.replaying) break;

                // Determine duration remaining and start point for animation
                const fullDurMs = Math.max(0, (seg.duration || 0)) * 1000 * playbackFactor;
                let animFrom = curH;
                let animTo = endH;
                let animDurMs = fullDurMs;

                if (curH > startH && curH < endH && endH !== startH) {
                    // user is already mid-way: compute fraction completed and remaining duration
                    const fracCompleted = (curH - startH) / (endH - startH);
                    animDurMs = Math.max(0, fullDurMs * (1 - fracCompleted));
                    // animFrom is current curH already set
                } else if (curH >= endH) {
                    // already past end; skip animation
                    animDurMs = 0;
                    animFrom = endH;
                    animTo = endH;
                } else {
                    // normal case: start from startH to endH with full duration
                    animFrom = curH <= startH ? startH : curH;
                    animTo = endH;
                    // if animFrom != startH and curH < startH, we should start from startH
                    if (animFrom === startH) {
                        animDurMs = fullDurMs;
                    }
                }

                // Now animate horizontal pan. We will monitor remaining time for blinking 2s before end.
                let blinkShown = false;
                // reset skip flag
                if (recordState.replayController) recordState.replayController.skipSegment = false;

                if (animDurMs > 0) {


                    // animateProperty will call onProgress from 0..1 over animDurMs
                    const result = await animateProperty(animDurMs, (p) => {
                        // compute current hOffset
                        preview.hOffset = animFrom + (animTo - animFrom) * p;
                        updatePreviewTransform();

                        // --- front reveal while panning: reveal front from left gradually up to 50% and then lock ---
                        try {
                            if (nextInit && previewImgFront && previewImgFront.style.display !== 'none') {
                                // compute scaled image width and total horizontal travel D_x
                                const rot = ((preview.rotation % 360) + 360) % 360;
                                const is90 = (rot === 90 || rot === 270);
                                const scaledW = (is90 ? preview.imgH : preview.imgW) * preview.scale;
                                const D_x = Math.max(0, scaledW - preview.containerW);

                                // tune: how many px before the end to start revealing
                                const revealStartPx = Math.min(preview.containerW * 0.6, 400);
                                const triggerStart = Math.max(0, D_x - revealStartPx);

                                // ensure transitions are off while we're changing clip-path progressively
                                previewImgFront.style.transition = '';

                                // reveal fraction 0..50 while preview.hOffset moves from triggerStart -> D_x
                                let revealPct = 0;
                                if (preview.hOffset > triggerStart) {
                                    revealPct = ((preview.hOffset - triggerStart) / Math.max(1, revealStartPx)) * (preview.containerW / scaledW) * 50; // 0..50
                                    if (revealPct < 0) revealPct = 0;
                                    if (revealPct >= 10 * (preview.containerW / scaledW)) {
                                        // revealPct = 50;
                                        console.log('');
                                    }
                                }

                                // If already locked at half, keep it exactly 50
                                if (frontAwaitingTap) {
                                    revealPct = 50 * (preview.containerW / scaledW);
                                } else if (revealPct >= 49 * (preview.containerW / scaledW)) {
                                    // first time we reach 50% -> lock and show hint
                                    revealPct = 49 * (containerW / scaledW);
                                    frontAwaitingTap = true;

                                    console.log('front locked at 50% at hOffset=', preview.hOffset, 'D_x=', D_x);

                                    if (typeof hintEl !== 'undefined' && hintEl) {
                                        hintEl.hidden = false; // show hint
                                    }
                                    // write the locked 50% explicitly (no transition)
                                    const clip50 = 'inset(0 50% 0 0)';
                                    if (previewImgFront.style.clipPath !== clip50) {
                                        previewImgFront.style.clipPath = clip50;
                                    }
                                    return; // done for this tick
                                }

                                // apply clip-path only when it actually changes (avoids extra writes)
                                const newClip = `inset(0 ${100 - revealPct}% 0 0)`;
                                if (previewImgFront.style.clipPath !== newClip) {
                                    previewImgFront.style.clipPath = newClip;
                                }

                                // --- show a 2px blue vertical line at the reveal border and keep it in sync ---
                                // create the line once (attached to previewCanvas)
                                let revealLine = document.getElementById('previewRevealLine');
                                if (!revealLine) {
                                    revealLine = document.createElement('div');
                                    revealLine.id = 'previewRevealLine';
                                    revealLine.style.position = 'absolute';
                                    revealLine.style.top = '0';
                                    revealLine.style.height = '100%';
                                    revealLine.style.width = '2px';
                                    revealLine.style.background = '#1e90ff'; // blue (change if you prefer another blue)
                                    revealLine.style.zIndex = '3';           // above previewImgFront (which uses zIndex = 2)
                                    revealLine.style.pointerEvents = 'none'; // don't block input
                                    revealLine.style.display = 'none';
                                    previewCanvas.appendChild(revealLine);
                                }

                                // only show the line when there's a visible reveal amount
                                if (typeof revealPct === 'number' && revealPct > 0) {
                                    // nextInit was set earlier per-row; use its saved hOffset as the front-image baseline
                                    const hx = (nextInit && typeof nextInit.hOffset !== 'undefined') ? nextInit.hOffset : 0;

                                    // scaledW computed above in this scope: use same value (if not available, compute)
                                    // (defensive fallback)
                                    const rot = ((preview.rotation % 360) + 360) % 360;
                                    const is90 = (rot === 90 || rot === 270);
                                    const scaledW_local = (typeof scaledW !== 'undefined') ? scaledW : ((is90 ? preview.imgH : preview.imgW) * preview.scale);

                                    // compute reveal pixel inside the front-image and map to container coords:
                                    const revealPxInImage = scaledW_local * (revealPct / 100);
                                    // front image is translated by -hx so image x=0 sits at container x = -hx
                                    let borderX = Math.round(revealPxInImage - hx);

                                    // clamp to preview container bounds
                                    borderX = Math.max(0, Math.min(preview.containerW, borderX));

                                    revealLine.style.left = borderX + 'px';
                                    revealLine.style.display = 'block';
                                } else {
                                    // hide when not revealing
                                    if (document.getElementById('previewRevealLine')) {
                                        document.getElementById('previewRevealLine').style.display = 'none';
                                    }
                                }

                            }
                        } catch (e) { /* defensive */ }



                        // update timer to show duration progression
                        setRecTimerText((p * (seg.duration || 0)).toFixed(1) + 's', 'replay');

                        // blinking logic: if remaining time <= 2000ms and blink not yet shown, show it
                        const elapsed = p * animDurMs;
                        const remaining = animDurMs - elapsed;
                        if (remaining <= 2000 && !blinkShown) {
                            blinkShown = true;
                            showBlink();
                        }
                    });

                    // if animateProperty was skipped (user tapped blink or resume triggered skip), result === 'skipped'
                    if (result === 'skipped') {
                        // user forced skip (via blink click or resume). Instead of forcing preview.hOffset
                        // to the next initial/end immediately, continue this same segment from the
                        // current visible preview.hOffset to animTo over the *remaining* time.
                        hideBlink();

                        // compute full distance originally intended and remaining fraction
                        const fullDist = animTo - animFrom;
                        const doneDist = preview.hOffset - animFrom;
                        let fracDone = 0;
                        if (Math.abs(fullDist) > 0.0001) {
                            fracDone = doneDist / fullDist;
                            // clamp
                            if (fracDone < 0) fracDone = 0;
                            if (fracDone > 1) fracDone = 1;
                        } else {
                            fracDone = 1;
                        }

                        // remaining time proportional to remaining distance
                        let remainingMs = Math.max(0, animDurMs * (1 - fracDone));

                        // If user has panned past the end or nearly at the end, snap to animTo immediately
                        if (Math.abs(animTo - preview.hOffset) < 0.5 || remainingMs <= 16) {
                            preview.hOffset = animTo;
                            updatePreviewTransform();
                        } else {
                            // show blink if the remaining time is short (keep previous UX)
                            if (remainingMs <= 2000) {
                                showBlink();
                            }

                            // Animate from the current visible position to animTo in remainingMs
                            const resumeStart = preview.hOffset;
                            // animateProperty will respect recordState.pausedReplay/skip flags
                            await animateProperty(remainingMs, (p) => {
                                // p is 0..1 across the remaining time
                                preview.hOffset = resumeStart + (animTo - resumeStart) * p;
                                updatePreviewTransform();

                                // update timer to reflect overall progress in this segment
                                // overallProgress = fracDone + p * (1 - fracDone)
                                const overallProgress = Math.min(1, Math.max(0, fracDone + p * (1 - fracDone)));
                                setRecTimerText((overallProgress * (seg.duration || 0)).toFixed(1) + 's', 'replay');

                                // blinking: if near the very end, ensure blink shown (defensive; showBlink already above if remaining <= 2s)
                                const elapsed = overallProgress * animDurMs;
                                const remaining = animDurMs - elapsed;
                                // keep blink visible while waiting near end
                                if (remaining <= 2000) {
                                    try { showBlink(); } catch (e) { }
                                }
                            });
                        }

                        // After finishing anim (or snapping) we simply fall through to the normal
                        // post-animation code below (vertical target/fade etc).  Do NOT force a
                        // jump to the next initial here — keep the natural flow so vertical switch
                        // and pause/wait happen in the same place as for a normal completion.
                    }

                } else {
                    // immediate set
                    preview.hOffset = animTo;
                    updatePreviewTransform();
                }

                // ensure blink hidden
                hideBlink();

                if (!recordState.replaying) break;

                // after horizontal pan, compute vertical target using the saved initial vOffset baseline
                const baselineV = init ? (typeof init.vOffset !== 'undefined' ? init.vOffset : preview.vOffset) : preview.vOffset;
                const deltaY = (seg.ydownPercent || 0) / 100 * preview.containerH;
                // compute max vertical based on current scale and rotation
                const imgHeightScaled = ((preview.rotation % 180) !== 0 ? preview.imgW : preview.imgH) * preview.scale;
                const maxV = Math.max(0, imgHeightScaled - preview.containerH);
                const targetV = clamp(baselineV + deltaY, 0, maxV);



                // show paused text and WAIT for user to tap/click to continue to next row (manual trigger)
                // BUT if autoplayback is enabled, skip the manual wait and continue automatically.
                if (fileSettings.autoplayback) {
                    // do not pause — just briefly show 'auto' status and continue
                    setRecTimerText('auto', 'replay');
                    // small natural pause of 150ms so UI updates are visible (optional)
                    await new Promise(r => setTimeout(r, 150));
                } else {
                    setRecTimerText('paused', 'paused');
                    // allow user interaction while waiting
                    recordState.pausedReplay = true;
                    // snapshot current segment state so resume can use it
                    // show optional hint (no-op if no hint element)
                    const hintEl = document.getElementById('hint');
                    if (hintEl) hintEl.hidden = false;

                    // wait for user action (pointerdown on preview/view or key)
                    await new Promise(resolve => {
                        function userContinueHandler(ev) {
                            try { ev.stopPropagation(); ev.preventDefault(); } catch (e) { }
                            // tell the shared resolver this was a real user action
                            if (recordState._resolveManualContinue) {
                                recordState._resolveManualContinue(true);
                            } else {
                                previewCanvas.removeEventListener('pointerdown', userContinueHandler);
                                viewCanvas.removeEventListener('pointerdown', userContinueHandler);
                                document.removeEventListener('keydown', keyHandler);
                            }
                            // cleanup and resolve
                            previewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            viewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            document.removeEventListener('keydown', keyHandler);
                            recordState._resolveManualContinue = null;
                            // restore paused flag
                            recordState.pausedReplay = false;
                            resolve();
                        }
                        function keyHandler(ev) {
                            if (ev.key === 'Enter' || ev.key === ' ') {
                                userContinueHandler(ev);
                            }
                        }
                        previewCanvas.addEventListener('pointerdown', userContinueHandler);
                        viewCanvas.addEventListener('pointerdown', userContinueHandler);
                        document.addEventListener('keydown', keyHandler);
                        // also keep a shared resolver so other parts can resume programmatically
                        recordState._resolveManualContinue = () => {
                            previewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            viewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            document.removeEventListener('keydown', keyHandler);
                            recordState._resolveManualContinue = null;
                            recordState.pausedReplay = false;
                            resolve();
                        };
                    });
                }
                


                // hide when not revealing
                if (document.getElementById('previewRevealLine')) {
                    document.getElementById('previewRevealLine').style.display = 'none';
                }

                // before the fade+switch, ensure the front-layer is fully revealed so the user sees the transition
                // Only auto-reveal here if the front is NOT currently awaiting an explicit user tap.
                try {
                    if (previewImgFront && previewImgFront.style.display !== 'none' && !frontAwaitingTap) {
                        previewImgFront.style.transition = 'clip-path 220ms ease';
                        previewImgFront.style.clipPath = 'inset(0 0 0 0)'; // full reveal
                        // wait for the small transition to finish
                        await new Promise(r => setTimeout(r, 240));
                        previewImgFront.style.transition = '';
                    }
                } catch (e) { /* ignore if awaiting not allowed */ }


                // do the fade+switch to next row naturally: fade 100ms, apply vOffset change, fade out 100ms
                // do the fade+switch to next row naturally: fade 100ms, apply vOffset and hOffset change if next initial exists, fade out 100ms
                // const nextInit = (initials && initials[i + 1]) ? initials[i + 1] : null;
                // await new Promise(r => {
                //     fadeCover.style.pointerEvents = 'auto';
                //     fadeCover.style.opacity = '0.9';
                //     setTimeout(() => r(), 100);
                // });
                if (nextInit) {
                    preview.scale = typeof nextInit.scale !== 'undefined' ? nextInit.scale : preview.scale;
                    preview.hOffset = typeof nextInit.hOffset !== 'undefined' ? nextInit.hOffset : preview.hOffset;
                    preview.vOffset = typeof nextInit.vOffset !== 'undefined' ? nextInit.vOffset : targetV;
                } else {
                    preview.hOffset = animTo;
                    preview.vOffset = targetV;
                }
                updatePreviewTransform();
                // await new Promise(r => {
                //     fadeCover.style.opacity = '0';
                //     setTimeout(() => { fadeCover.style.pointerEvents = 'none'; r(); }, 100);
                // });

                hideFront();

                // resume replay state
                recordState.pausedReplay = false;
                setRecTimerText('0.0s', 'replay');

                if (!recordState.replaying) break;



            }

            // finish replay
            stopReplay();
        }



        // Replace the existing stopReplay() with this safer version
        function stopReplay() {
            // mark stop flags first
            recordState.replaying = false;
            recordState.pausedReplay = false;
            overlayReplay.textContent = 'Replay';
            overlayRecord.disabled = false;

            // allow user to pan/zoom again
            preview.lockZoom = false;
            preview.lockVertical = false;

            // reset timer UI
            setRecTimerText('0.0s', 'paused');

            // hide pause button if exists
            const btnPause = $('#overlayPause');
            if (btnPause) {
                btnPause.hidden = true;
                btnPause.textContent = 'Pause'; // reset label so next start shows Pause
            }

            // hide playback controls if present
            const pbRew_el = document.getElementById('overlayPBRew');
            const pbFwd_el = document.getElementById('overlayPBFwd');
            const pbWrapper = document.getElementById('overlayPBWrapper');
            if (pbRew_el) pbRew_el.hidden = true;
            if (pbFwd_el) pbFwd_el.hidden = true;
            if (pbWrapper) pbWrapper.style.display = 'none';


            // hide any temporary UI left over from replay
            const blink = document.getElementById('replayBlinkLine');
            if (blink) { blink.style.display = 'none'; }
            const fade = document.getElementById('replayFadeCover');
            if (fade) { fade.style.opacity = '0'; fade.style.pointerEvents = 'none'; }

            // clear any controller flags and request abort
            if (!recordState.replayController) recordState.replayController = {};
            recordState.replayController.skipSegment = false;
            recordState.replayController.aborted = true;

            // If we are currently waiting for a user tap (the code attached once handlers),
            // dispatch a synthetic pointerdown so the waiting Promise resolves and the replay loop can exit.
            try {
                previewCanvas.dispatchEvent(new PointerEvent('pointerdown', { bubbles: true }));
                viewCanvas.dispatchEvent(new PointerEvent('pointerdown', { bubbles: true }));
                // also dispatch a keydown for Enter/Space fallback (some environments)
                document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
            } catch (e) {
                // ignore if synthetic events not allowed
            }

            // --- CLEANUP POINTER STATE (fix: leftover pointers causing ghost-zoom/pinch) ---
            try {
                // release any pointer captures and clear preview active pointers
                for (const id of activePointers.keys()) {
                    try { previewCanvas.releasePointerCapture(id); } catch (e) { /* ignore */ }
                }
                activePointers.clear();
            } catch (e) { /* ignore */ }

            // reset preview internal flags that control dragging/pinch
            preview.dragging = false;
            preview.lastPointer = null;
            preview._pinchBase = null;

            // also clean view pointer state just in case
            try {
                for (const id of viewActivePointers.keys()) {
                    try { viewCanvas.releasePointerCapture(id); } catch (e) { /* ignore */ }
                }
                viewActivePointers.clear();
            } catch (e) { /* ignore */ }
            viewState._dragging = false;
            viewState._lastPointer = null;

        }



        // overlayReplay click handler (toggle start/stop)
        if (overlayReplay) {
            overlayReplay.addEventListener('click', () => {
                if (recordState.replaying) {
                    stopReplay();
                } else {
                    startReplay();
                }
            });
        }

        // overlay pause (toggle pause/resume)
        // Replace existing overlayPause click handler with this:
        document.addEventListener('click', (e) => {
            if (!(e.target && e.target.id === 'overlayPause')) return;

            // toggle paused state
            recordState.pausedReplay = !recordState.pausedReplay;
            const btn = e.target;
            btn.textContent = recordState.pausedReplay ? 'Resume' : 'Pause';

            if (recordState.pausedReplay) {
                // PAUSED: allow user panning (both horizontal & vertical), but keep zoom locked
                preview.lockZoom = true;
                preview.lockVertical = false; // allow both horizontal & vertical pans
                // un-block input: isReplayActive() will now return false because pausedReplay=true
                setRecTimerText('paused', 'replay');
            } else {
                // RESUMED: re-lock pans (both horizontal and vertical locked during replay)
                // we will recalculate which segment to continue from
                preview.lockZoom = true;
                preview.lockVertical = true;

                // prepare controller to skip the current running animation and jump into recalculation
                if (!recordState.replayController) recordState.replayController = { skipSegment: false, aborted: false };
                // set skip flag to abort any current animateProperty loop immediately; the main loop will then recalc

                recordState.replayRecalcOnResume = true;   // just recalc, do NOT skip
                recordState.replayController.skipSegment = false;  // ensure no skip happens                

                // update UI
                setRecTimerText('0.0s', 'replay');
            }
        });


        // ensure overlayReplay visibility on load if segments exist
        try { overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length); } catch (e) { }


        if (btnViewToggle) {
            btnViewToggle.addEventListener('click', () => {
                togglePlayPause();
            });
        }

        function backToSetup() {
            // stop any running animation / timers and set state to "Ready"
            stopAllPlaying();

            // copy current view state back into preview/file settings so preview shows what user last saw
            preview.scale = viewState.scale;
            preview.hOffset = viewState.hOffset;
            preview.vOffset = viewState.vOffset;
            preview.rotation = viewState.rotation;

            // ensure preview image src is set (defensive)
            if (viewImg && viewImg.src && (!previewImg || !previewImg.src)) {
                previewImg.src = viewImg.src;
            }

            // unlock preview interactions
            preview.lockVertical = false;
            preview.lockZoom = false;

            // hide view, show setup
            viewPage.style.display = 'none';
            viewPage.setAttribute('aria-hidden', 'true');
            const setupPage = $('#setupPage');
            setupPage.style.display = 'flex';

            // force recompute container dims and redraw preview
            updatePreviewTransform(true);

            // persist loaded settings
            saveRecord();

            // show replay only if both segments and initials exist for this file
            try {
                overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length && fileSettings.initials && fileSettings.initials.length);
            } catch (e) {
                overlayReplay.hidden = true;
            }

        }



        if (btnViewBack) {
            btnViewBack.addEventListener('click', backToSetup);
        }


        // ======= Open view (enter view) =======
        btnOpenView.addEventListener('click', () => {
            if (!currentFile) return alert('No file loaded');
            fileSettings.duration = Number(inpDuration.value) || DEFAULTS.duration;
            fileSettings.delay = Number(inpDelay.value) || DEFAULTS.delay;
            fileSettings.ydownPercent = Number(inpYdown.value) || DEFAULTS.ydownPercent;
            if (!fileSettings.startZoom) fileSettings.startZoom = preview.scale;
            enterView();
        });

        // ======= Update preview on image load / resize =======
        previewImg.onload = () => updatePreviewTransform(true);
        window.addEventListener('resize', () => updatePreviewTransform(true));

        // ======= View page logic (modified) =======
        function updateViewPauseButtonLabel() {
            if (!btnViewToggle) return;
            btnViewToggle.textContent = (viewState.state === 'Playing') ? 'Pause' : 'Play';
        }

        // helper to recalc dims for view (also used after rotate)
        function enterView_recalcAndApply() {
            const rect = viewCanvas.getBoundingClientRect();
            viewState.containerW = rect.width; viewState.containerH = rect.height;
            viewState.imgW = preview.imgW; viewState.imgH = preview.imgH;
            viewState.startZoom = fileSettings.startZoom || fileSettings.zoom || preview.scale || 1;
            viewState.scale = viewState.startZoom;
            viewState.startOffsetX = Number(fileSettings.startOffsetX) || 0;
            viewState.startOffsetY = Number(fileSettings.startOffsetY) || 0;
            viewState.duration = Number(fileSettings.duration) || DEFAULTS.duration;
            viewState.delay = Number(fileSettings.delay) || DEFAULTS.delay;
            viewState.ydownPercent = Number(fileSettings.ydownPercent) || DEFAULTS.ydownPercent;
            // rotation from preview
            viewState.rotation = preview.rotation || 0;
            // if rotation 90/270 swap dims
            const is90 = (viewState.rotation % 180) !== 0;
            const scaledW = (is90 ? viewState.imgH : viewState.imgW) * viewState.scale;
            const scaledH = (is90 ? viewState.imgW : viewState.imgH) * viewState.scale;
            viewState.D_x = Math.max(0, scaledW - viewState.containerW);
            viewState.D_y = Math.max(0, scaledH - viewState.containerH);
            viewState.startOffsetX = clamp(viewState.startOffsetX, 0, viewState.D_x);
            viewState.startOffsetY = clamp(viewState.startOffsetY, 0, viewState.D_y);
            viewState.hOffset = viewState.startOffsetX;
            viewState.vOffset = viewState.startOffsetY;
            // compute vx as full-travel / duration (for use when resuming)
            const travelX = Math.max(0, viewState.D_x - viewState.startOffsetX);
            viewState.vx = travelX <= 0 ? 0 : travelX / viewState.duration;
            // apply transform
            viewImg.style.transform = `translate3d(${-viewState.hOffset}px, ${-viewState.vOffset}px, 0) rotate(${viewState.rotation}deg) scale(${viewState.scale})`;
        }

        // enter view (now starts in Paused so user can pan initial)
        function enterView() {
            $('#setupPage').style.display = 'none';
            viewPage.style.display = 'flex';
            viewPage.setAttribute('aria-hidden', 'false');

            enterView_recalcAndApply();  // <-- now canvas is visible

            viewState.state = 'Paused';
            updateStatePill('Paused');
            updateViewPauseButtonLabel();

            if (viewState.playReqId) cancelAnimationFrame(viewState.playReqId);
            viewState.playReqId = null;
        }


        // Update state label
        function updateStatePill(text) { statePill.textContent = text; }

        // Apply transform with optional transition, always clamp offsets
        function applyViewTransform(transition = false) {
            // recalc current scaled dims based on rotation & scale
            const rot = ((viewState.rotation % 360) + 360) % 360;
            const is90 = (rot === 90 || rot === 270);
            const scaledW = (is90 ? viewState.imgH : viewState.imgW) * viewState.scale;
            const scaledH = (is90 ? viewState.imgW : viewState.imgH) * viewState.scale;
            viewState.D_x = Math.max(0, scaledW - viewState.containerW);
            viewState.D_y = Math.max(0, scaledH - viewState.containerH);
            viewState.hOffset = clamp(viewState.hOffset, 0, viewState.D_x);
            viewState.vOffset = clamp(viewState.vOffset, 0, viewState.D_y);
            if (transition) { viewImg.style.transition = 'transform 320ms ease'; setTimeout(() => viewImg.style.transition = '', 360); }
            viewImg.style.transform = `translate3d(${-Math.round(viewState.hOffset)}px, ${-Math.round(viewState.vOffset)}px, 0) rotate(${viewState.rotation}deg) scale(${viewState.scale})`;
        }

        // View pointer handlers (dragging when paused)
        let viewActivePointers = new Map();
        viewCanvas.addEventListener('pointerdown', (e) => {
            viewCanvas.setPointerCapture(e.pointerId);
            viewActivePointers.set(e.pointerId, e);
            if (viewActivePointers.size === 1) {
                viewState._dragging = true;
                viewState._lastPointer = { x: e.clientX, y: e.clientY };
            }
        });
        viewCanvas.addEventListener('pointermove', (e) => {
            if (!viewActivePointers.has(e.pointerId)) return;
            viewActivePointers.set(e.pointerId, e);
            if (viewActivePointers.size === 1 && viewState._dragging) {
                const p = viewState._lastPointer;
                const dx = e.clientX - p.x, dy = e.clientY - p.y;
                viewState._lastPointer = { x: e.clientX, y: e.clientY };
                if (viewState.state === 'Paused') {
                    viewState.hOffset = clamp(viewState.hOffset - dx, 0, viewState.D_x);
                    viewState.vOffset = clamp(viewState.vOffset - dy, 0, viewState.D_y);
                    applyViewTransform();
                    updateStatePill('Paused');
                }
            }
        });
        viewCanvas.addEventListener('pointerup', (e) => { if (viewActivePointers.has(e.pointerId)) { viewCanvas.releasePointerCapture(e.pointerId); } viewActivePointers.delete(e.pointerId); if (viewActivePointers.size === 0) { viewState._dragging = false; viewState._lastPointer = null; } });
        viewCanvas.addEventListener('pointercancel', (e) => { viewActivePointers.delete(e.pointerId); viewState._dragging = false; viewState._lastPointer = null; });

        // click handler for starting/controls/atEnd (use click to avoid interfering with drag)
        viewCanvas.addEventListener('click', (e) => {
            if (viewState._dragging) return;
            const rect = viewCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const half = rect.width / 2;
            if (viewState.state === 'Ready' || viewState.state === 'Paused') {
                // If paused and user clicked/tapped center, we'll treat it as resume (toggle)
                if (viewState.state === 'Paused') {
                    // if clicking center, call resume logic
                    if (approxEqual(viewState.hOffset, viewState.startOffsetX, 1)) {
                        // if at initial X, wait for delay then start
                        updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                        if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                        viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
                    } else {
                        // not initial X: compute remaining seconds using vx and start immediately
                        startPlaying();
                    }
                } else {
                    // was Ready (edge case) -> start waiting
                    viewState.state = 'WaitingDelay';
                    updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                    if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                    viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
                }
            } else if (viewState.state === 'AtEndAwaitingTrigger') {
                if (x >= half) handleEndTapRight(); else handleEndTapLeft();
            }
        });

        // Pause/Resume control is just double-tap in UI; we provide no separate buttons in view for simplicity
        // But we'll attach keyboard fallback (for debugging)
        document.addEventListener('keydown', (e) => { if (e.key === ' ') { if (viewState.state === 'Playing') pausePlaying(); else if (viewState.state === 'Paused') { startPlaying(); } } });



        // Playing loop functions (start/pause/resume/stop)
        function startPlaying() {
            // compute vx if zero
            const totalTravel = Math.max(0.0001, viewState.D_x - viewState.startOffsetX);
            // If vx is zero (means not computed or changed), compute from duration
            if (!viewState.vx || viewState.vx === 0) {
                viewState.vx = totalTravel / (viewState.duration || DEFAULTS.duration);
            }
            viewState.state = 'Playing';
            viewState._playStartTimestamp = performance.now();
            viewState._hOffsetAtPlayStart = viewState.hOffset;
            if (viewState.playReqId) cancelAnimationFrame(viewState.playReqId);
            viewState.playReqId = requestAnimationFrame(viewLoop);
            updateStatePill('Playing');
        }

        function viewLoop() {
            if (viewState.state !== 'Playing') return;
            const elapsed = (performance.now() - viewState._playStartTimestamp) / 1000;
            const newH = Math.min(viewState.D_x, viewState._hOffsetAtPlayStart + viewState.vx * elapsed);
            viewState.hOffset = newH;
            applyViewTransform();
            const travelTot = Math.max(1, viewState.D_x - viewState.startOffsetX);
            const progress = Math.round(((viewState.hOffset - viewState.startOffsetX) / travelTot) * 100);
            updateStatePill('Playing ' + Math.max(0, Math.min(100, progress)) + '%');
            if (viewState.hOffset >= viewState.D_x - 0.5) {
                viewState.hOffset = viewState.D_x;
                applyViewTransform();
                viewState.state = 'AtEndAwaitingTrigger';
                updateStatePill('At End');
                return;
            }
            viewState.playReqId = requestAnimationFrame(viewLoop);
        }

        function togglePlayPause() {
            if (viewState.state === 'Playing') {
                // go to Paused at current position
                pausePlaying();
            } else if (viewState.state === 'Paused') {
                // smart resume (uses startOffsetX vs current hOffset)
                resumePlaying();
            } else if (viewState.state === 'WaitingDelay') {
                // cancel pending delay and stay paused
                if (viewState._delayTimeout) {
                    clearTimeout(viewState._delayTimeout);
                    viewState._delayTimeout = null;
                }
                viewState.state = 'Paused';
                updateStatePill('Paused');
            } else {
                // from Ready / AtEnd / other -> start from beginning
                startPlaying();
            }
            updateViewPauseButtonLabel();
        }

        function pausePlaying() {
            if (viewState.state !== 'Playing') return;
            const elapsed = (performance.now() - viewState._playStartTimestamp) / 1000;
            viewState.hOffset = Math.min(viewState.D_x, viewState._hOffsetAtPlayStart + viewState.vx * elapsed);
            if (viewState.playReqId) cancelAnimationFrame(viewState.playReqId);
            viewState.state = 'Paused';
            applyViewTransform();
            updateStatePill('Paused');
        }

        function resumePlaying() {
            if (viewState.state !== 'Paused') return;
            // if current x equals startOffsetX within tolerance -> add delay
            if (approxEqual(viewState.hOffset, viewState.startOffsetX, 1)) {
                updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
            } else {
                // start playing immediately — vx already holds speed computed earlier
                viewState._hOffsetAtPlayStart = viewState.hOffset;
                viewState._playStartTimestamp = performance.now();
                viewState.state = 'Playing';
                viewState.playReqId = requestAnimationFrame(viewLoop);
                updateStatePill('Playing');
            }
        }

        function stopAllPlaying() {
            if (viewState._delayTimeout) { clearTimeout(viewState._delayTimeout); viewState._delayTimeout = null; }
            if (viewState.playReqId) { cancelAnimationFrame(viewState.playReqId); viewState.playReqId = null; }
            viewState.state = 'Ready';
            updateStatePill('Ready');
        }

        // End tap handlers (unchanged behavior but clamped)
        function handleEndTapRight() {
            // if both at end horizontally and vertically -> reset to start and play next (original behavior)
            if (Math.abs(viewState.hOffset - viewState.D_x) < 1 && Math.abs(viewState.vOffset - viewState.D_y) < 1) {
                viewState.hOffset = viewState.startOffsetX;
                viewState.vOffset = viewState.startOffsetY;
                viewState.scale = viewState.startZoom;
                applyViewTransform(true);
                viewState.state = 'WaitingDelay';
                updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
            } else {
                const deltaY = viewState.containerH * (viewState.ydownPercent / 100);
                const scaledH = ((viewState.rotation % 180) !== 0 ? viewState.imgW : viewState.imgH) * viewState.scale;
                viewState.D_y = Math.max(0, scaledH - viewState.containerH);
                viewState.vOffset = clamp(viewState.vOffset + deltaY, 0, viewState.D_y);
                viewState.hOffset = viewState.startOffsetX;
                applyViewTransform(true);
                viewState.state = 'WaitingDelay';
                updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
            }
        }

        function handleEndTapLeft() {
            const deltaY = viewState.containerH * (viewState.ydownPercent / 100);
            const scaledH = ((viewState.rotation % 180) !== 0 ? viewState.imgW : viewState.imgH) * viewState.scale;
            viewState.D_y = Math.max(0, scaledH - viewState.containerH);
            viewState.vOffset = clamp(viewState.vOffset - deltaY, 0, viewState.D_y);
            viewState.hOffset = viewState.startOffsetX;
            applyViewTransform(true);
            viewState.state = 'WaitingDelay';
            updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
            if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
            viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
        }

        // Back to setup page (we use an overlay click on the View page to go back — easiest is to click view area with two fingers or use escape)
        viewPage.addEventListener('dblclick', () => { stopAllPlaying(); viewPage.style.display = 'none'; $('#setupPage').style.display = 'flex'; updateStatePill('Ready'); });

        // ======= Initialization & last file restore =======
        async function appInit() {
            inpDuration.value = localStorage['partitur:defaultDuration'] || DEFAULTS.duration;
            inpDelay.value = localStorage['partitur:defaultDelay'] || DEFAULTS.delay;
            inpYdown.value = localStorage['partitur:defaultYdown'] || DEFAULTS.ydownPercent;
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_FILES, 'readonly'); const st = tx.objectStore(STORE_FILES);
                let latest = null;
                st.openCursor().onsuccess = async e => {
                    const cur = e.target.result;
                    if (cur) { if (cur.value && cur.value.lastUsed && (!latest || cur.value.lastUsed > latest.lastUsed)) latest = cur.value; cur.continue(); } else {
                        if (latest && latest.handle) {
                            try { const ok = await verifyFileHandlePermission(latest.handle); if (ok) { const f = await latest.handle.getFile(); await loadFile(f, latest.handle); } } catch (err) { console.warn('reopen fail', err); }
                        }
                    }
                };
            } catch (err) { console.warn('init error', err); }
        }

        async function verifyFileHandlePermission(handle) {
            if (!handle) return false;
            try {
                if (handle.queryPermission) {
                    const q = await handle.queryPermission({ mode: 'read' });
                    if (q === 'granted') return true;
                }
                if (handle.requestPermission) {
                    const r = await handle.requestPermission({ mode: 'read' });
                    return r === 'granted';
                }
            } catch (e) { return false; }
            return true;
        }

        appInit().catch(e => console.warn(e));

        // save UI default changes
        inpDuration.addEventListener('change', () => localStorage['partitur:defaultDuration'] = inpDuration.value);
        inpDelay.addEventListener('change', () => localStorage['partitur:defaultDelay'] = inpDelay.value);
        inpYdown.addEventListener('change', () => localStorage['partitur:defaultYdown'] = inpYdown.value);

        // // update start label when preview changes (debounce)
        // function refreshStartLabelDebounced(){
        //   setTimeout(()=> updateStartLabel(), 150);
        // }
        // updateStartLabel();

        // ensure preview dims update
        window.addEventListener('resize', () => { updatePreviewTransform(true); if (viewPage.style.display === 'block') enterView_recalcAndApply(); });
        previewImg.onload = () => { updatePreviewTransform(true); if (viewPage.style.display === 'block') enterView_recalcAndApply(); };

    </script>
    <script>
        /* small script to enforce styles at runtime and hide view button if created dynamically */
        (function () {
            // hide view button (defensive - supports multiple possible selectors)
            const viewSelectors = ['#viewButton', '.view-button', '.btn-view', '.viewBtn'];
            viewSelectors.forEach(s => {
                const el = document.querySelector(s);
                if (el) el.style.display = 'none';
            });

            // ensure zoom label color reflects the CSS variable (useful if label text set after load)
            const setZoomLabelColor = () => {
                const label = document.getElementById('zoomLabel') || document.querySelector('.zoom-value') || document.querySelector('label[for="zoomSlider"]');
                if (!label) return;
                // read the CSS var (fallback to the same hex)
                const uiBlue = getComputedStyle(document.documentElement).getPropertyValue('--ui-blue') || '#1e90ff';
                label.style.color = uiBlue.trim();
                label.style.fontWeight = '600';
            };

            // On DOM ready and when new content might be injected
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setZoomLabelColor);
            } else {
                setZoomLabelColor();
            }

            // If your app updates zoom label dynamically, call setZoomLabelColor() after updates.
            // e.g. after setting label text: document.getElementById('zoomLabel').textContent = '200%'; setZoomLabelColor();
        })();
    </script>

</body>

</html>
